schema {
  query: Query
  mutation: Mutation
}
scalar BigInt
scalar Buffer
scalar Date
scalar DateTime
scalar Decimal
"The `Int32` scalar type represents non-fractional signed whole numeric values. Int32 can represent values between -(2^31) and 2^31 - 1. "
scalar Int32
"The `Int64` scalar type represents non-fractional signed whole numeric values. Int64 can represent values between -(2^63) and 2^63 - 1. "
scalar Int64
"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)"
scalar JSON
scalar JSONObject
scalar Time
"A `Timestamp` represents a point in time independent of any time zone or calendar, represented as seconds and fractions of seconds at nanosecond resolution in UTC Epoch time."
scalar Timestamp
scalar UUID
""
scalar Uint64
scalar Upload
scalar Void
"Account balance information"
type AccountBalanceReturn {
  "Available balance in cents"
  available: Int
  "Pending balance in cents"
  pending: Int
  type: String
}
type AccountLink {
  created: Int
  expires_at: Int
  object: String
  url: String
}
type AccountManager implements DriveUser {
  email: String
  firstName: String
  lastName: String
  phone: String
}
type Activity {
  id: String
  name: String
  value: String
}
"See CampaignMembership for details"
type AdminCampaign {
  id: ID!
}
type Asset {
  assetId: Int
  assetType: AssetType
  assetTypeId: String
  attachment: String
  createdAt: String
  description: String
  expirationDate: String
  id: String
  image: String
  isDeleted: Boolean
  isSponsored: Boolean
  location: String
  name: String
  pricing: Float
  quantity: Int
  sponsors: [SponsorInAssets]
  sponsorshipGroup: SponsorshipGroup
  sponsorshipGroupId: String
  startDate: String
  updatedAt: String
}
type AssetType {
  assetTypeValue: [AssetTypeValue]
  attachmentType: String
  description: String
  fees: Int
  id: String
  isActive: Boolean
  minPrice: Float
  name: String
  pricing: Int
  productionSource: String
}
type AssetTypeValue {
  id: String
  value: Int
}
type Assets {
  assets: [Asset]
  totalCount: Int
}
type AssetsCount {
  sponsoredCount: Int
  totalCount: Int
}
type Attachment {
  assetId: String
  assignedAt: String
  attachment: String
  cartId: Int
  packageId: String
  sponsorId: String
  status: String
}
type Auth implements Tokens {
  accessToken: String
  refreshToken: String
}
type AuthChallenge implements Tokens {
  accessToken: String
  challenges: [UserChallenge]
  refreshToken: String
}
type AuthenticationFlow {
  name: String
  redirectUrl: String
}
type BillingAddress {
  city: String
  country: String
  line1: String
  line2: String
  postal_code: String
  state: String
}
type BillingDetails {
  address: BillingAddress
  email: String
  name: String
  phone: String
}
type Brand {
  label: String
  value: Int
}
"@deprecated: will be merged with DriveCampaign instead This type is for Drive's Campaign Management. Users must have the Drive's permission to access any data. We are working on migrating this type to DriveCampaign."
type Campaign {
  "Account Manager of Campaign"
  accountManager: AccountManager
  "Activity type of campaign. e.g. 'football', 'baseball', etc."
  activityType: String
  "URL for Generated Report of (Active) Campaign"
  campaignActiveReportUrl: String
  "City + State string of campaign. e.g. 'Dallas, TX'"
  campaignTerritory: String
  "Donations statistics of campaign. All values will be 0 if campaign is 'upcoming'"
  donations: Donations
  "Participant email delivery info of campaigns"
  emails: EmailsInfo
  "End date of fundraiser"
  endDate: DateTime
  "Entity ID of campaign. This ID used to obtain financial/payment info"
  entityId: Int
  "Date when campaign is finalized"
  finalizedDate: DateTime
  "Shipping status for gear items. Values are 'delivered','pre_transit','in_transit','failure','available_for_pickup','unknown','out_for_delivery', 'return_to_sender','cancelled','error'"
  gearStatus: String
  "Group Leader"
  groupLeader: GroupLeader
  "Deal ID of campaign in Hubspot."
  hubspotId: String
  id: Int
  "Cover image of campaign"
  image: String
  "Initial goal amount to fundraise in cents"
  initialGoalCents: Int
  "Link to invite participants to the campaign"
  inviteParticipantUrl: String
  "Unique join-code of campaign"
  joinCode: Int
  "URL for the fundraiser KYC Form."
  kycFormUrl: String
  "Campaign kyc status"
  kycStatus: CampaignKycStatusResult
  "Mailing address of campaign."
  mailingAddress: String
  "MDM Contact of Campaign"
  mdm: MDMDetails
  name: String
  "Statistics info of campaign participants"
  participants: ParticipantsInfo
  "Last withdrawal payment status. Values are 'Initializing', 'Processing', 'Transferred', 'Cut', 'Deposited', 'Expired' or 'Failed'"
  paymentStatus: String
  "Payment type when campaign finalized. Values are 'Check to Office', 'Check to Salesrep', 'Check to Fundraiser', or 'Direct Deposit'."
  paymentType: String
  "Base64 generated CSV file for preload emails report of event"
  preloadReport: String
  "Download URL for Final Receipt (PDF) of settled campaigns"
  receiptDownloadUrl: String
  "Settlement Details for Closed Campaigns"
  settlementDetails: SettlementDetails
  "Settlement Confirmation Status for Closed Campaigns. Values are 'UNSUBMITTED', 'IN_REVIEW' and 'VERIFIED'"
  settlementStatus: String
  slug: String
  "Start date of fundraiser"
  startDate: DateTime
  status: String
  "Size of team/group of campaign"
  teamSize: Int
  "Not in-use. Deprecated"
  testEmails: String
  "Total amount raised in cents"
  totalRaisedCents: Int
  "The total raised combined this organization has previously ran campaigns"
  totalRaisedHistory: Int
  "Tracking link for shipping gear items."
  trackingLink: String
}
type CampaignDates {
  endDateTime: String!
  isAllDay: Boolean
  startDateTime: String!
}
"Resigned campaigns"
type CampaignHistoryList {
  CampaignHistoryEndDate: String
  CampaignHistorySlug: String
  CampaignHistoryStartDate: String
  campaignName: String
  campaignTotalRaised: Int
}
type CampaignKyc {
  status: CampaignKycStatusEnum
}
type CampaignKycStatusResult {
  data: CampaignKycStatus
  type: CampaignKycType
}
type CampaignList {
  count: Int
  list: [Campaign]!
  offset: Int
}
type CampaignPersonList {
  id: Int!
}
type CampaignPersonListEntryDelete {
  id: Int!
}
type CampaignSearchFilter {
  dateCreated: DateTime
  dateUpdated: DateTime
  "Collection (key/values) of saved search criteria."
  filterCriteria: JSON
  "Name of the saved search filter."
  filterName: String
  "ID of saved search filters."
  id: Int
}
"Owned by vault Extended by wallet Card issued by vault via Stripe"
type Card {
  cardNumber: String
  cardType: VaultCardType
  cardholderId: String
  cvv: String
  expirationMonth: Int
  expirationYear: Int
  gatewayId: String
  id: String!
  last4: String
  metadata: VaultCardMetadata
  spendingLimitAmount: Int
  spendingLimitInterval: VaultSpendingLimitInterval
  status: VaultCardStatus
  walletEverActivated: Boolean
}
type CardDetails {
  brand: String
  country: String
  exp_month: Int
  exp_year: Int
  last4: String
}
type CarouselItem {
  id: Int
  image: String
  media_type: String
  url: String
}
type Check {
  amount: Decimal!
  campaignId: Int!
  checkNumber: String!
  created: Timestamp!
  destination: Account!
  effective: Timestamp!
  expiration: Timestamp!
  payee: Payee!
  status: CheckStatus!
  transactionId: UUID!
}
type Cheer {
  anonymous: Boolean
  createdAt: DateTime
  donorMessage: String
  donorName: String
  firstName: String
  id: Int
  images: [String]
  lastName: String
  subtotalCents: Int
}
type CheerWall {
  createdAt: DateTime
  donorMessage: String
  donorName: String
  images: [String]
  participantName: String
  subtotalCents: Int
}
type CombinedPermissions {
  permissions: [String]
}
type CommonCalendar {
  activity: String
  bus_count: Int
  comments: String
  confirmed: String
  driver_name: String
  driver_phone: String
  end_time: String
  event_date: String
  facility: String
  g_s: String
  gender: String
  home_field: String
  id: Int
  levels: String
  opponent: String
  place: String
  season_id: Int
  sports_code: String
  sports_description: String
  sports_group: String
  sports_name: String
  start_time: String
  vehicle_id: String
  vehicle_type: String
}
type CommonGrid {
  activity: String
  bus_count: Int
  comments: String
  confirmed: String
  driver_name: String
  driver_phone: String
  end_time: String
  event_date: String
  facility: String
  g_s: String
  gender: String
  home_field: String
  id: Int
  levels: String
  place: String
  season_id: Int
  sports_code: String
  sports_description: String
  sports_group: String
  sports_name: String
  start_time: String
  vehicle_id: String
  vehicle_type: String
}
type CommonSchedules {
  activity: String
  bus_count: Int
  bus_departure_location: String
  bus_early_dismissal_time: String
  bus_estimated_return_time: String
  bus_time: String
  cancellation_status: String
  comments: String
  confirmed: String
  driver_name: String
  driver_phone: String
  end_time: String
  event_date: String
  facility: String
  g_s: String
  gender: String
  home_field: String
  id: Int
  levels: String
  opponent: String
  place: String
  season_id: Int
  sports_code: String
  sports_description: String
  sports_group: String
  sports_name: String
  start_time: String
  vehicle_id: String
  vehicle_type: String
}
type CommonSheet {
  activity: String
  bus_count: Int
  comments: String
  confirmed: String
  driver_name: String
  driver_phone: String
  end_time: String
  event_date: String
  facility: String
  fee: Float
  g_s: String
  gender: String
  home_field: String
  id: Int
  levels: String
  place: String
  season_id: Int
  sports_code: String
  sports_description: String
  sports_group: String
  sports_name: String
  start_time: String
  vehicle_id: String
  vehicle_type: String
}
type Consumer {
  accessBy: String
  color: String!
  description: String!
  icon: String!
  id: String!
  inApps: Boolean!
  logo: String!
  mask: String!
  modal: ConsumerModal
  title: String!
  url: String!
}
type ConsumerModal {
  descriptions: [String]!
  header: String!
}
type ContractItem {
  event_contract: EventContract
  event_id: Int
  id: Int
}
type ContractSignees {
  auth_hash: String
  comments: String
  email_id: String
  event_contract_number: Int
  id: Int
  original_contract: String
  sent_date: Date
  sign_contract: String
  sign_date: Date
  sign_status: String
}
"Owned by Vault Only used in legacy createCard"
type CoreCardFields {
  cardId: String!
  expirationMonth: Int!
  expirationYear: Int!
  gatewayId: String
  last4: String!
  name: String!
}
type CreatedFundraiserUser {
  id: Int!
}
type CreatedOtkEntry {
  id: Int!
}
type CreatedParticipantRewards {
  id: Int!
}
type CurrentCustomersDeals {
  activity: String
  dealStage: String
  entityId: String
  fundraiserStatus: String
  id: String
  lastLaunch: String
  leaderFirstName: String
  leaderLastName: String
  slug: String
  snapFundraiserId: String
  totalRaised: Int
}
"Information of custom email templates"
type CustomContactTemplates {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: Int
  message: String
  name: String
  subject: String
}
type DailyCalendarBusScheduleEvents {
  activity: String
  activityType: String
  bus_time: String
  calendarDate: String
  comments: String
  confirmed: String
  departure_location: String
  early_dismissal_required: String
  early_dismissal_time: String
  end_time: String
  estimated_return_time: String
  event_comments: String
  event_date: String
  event_id: Int
  g_s: String
  location: String
  num_buses: Int
  num_buses_text: Int
  opponent: String
  place: String
  sport: String
  sportGender: String
  sportLevel: String
  sport_name: String
  start_time: String
}
type DailyCalendarBusScheduleExportData {
  activity: String
  bus_time: String
  comments: String
  confirmed: String
  departure_location: String
  driver_name: String
  driver_phone: String
  early_dismissal_required: String
  early_dismissal_time: String
  end_time: String
  estimated_return_time: String
  event_date: String
  event_id: Int
  g_s: String
  gender: String
  groupval: String
  level1: String
  location: String
  num_buses_text: Int
  opponent: String
  place: String
  sport_description: String
  sport_name: String
  start_time: String
  transport_comments: String
  vehicle_id: String
  vehicle_type: String
}
type DailyCalendarEvent {
  activity: String
  comments: String
  departure_location: String
  description: String
  early_dismissal_time: String
  end_time: String
  estimated_return_time: String
  eventId: Int
  eventTransportDetails: [EventTransportDetails]
  event_date: Date
  location: String
  num_buses: Int
  officials: [Official]
  opponent: String
  preparations: [Preparation]
  schoolInfo: SchoolInfo
  season_team: Int
  season_years: String
  start_time: String
  workers: [Worker]
}
type DailyCalendarEventTransportDetails {
  driver_name: String
  driver_phone: String
  event_transport_details_id: Int
  vehicle_id: String
  vehicle_type: String
}
type DailyCalendarOfficialDuties {
  Address: String
  City: String
  Home_Phone: String
  SSN: String
  State: String
  Work_Phone: String
  Zip: String
  cell_phone: String
  duty: String
  email: String
  id: Int
  offic_id: String
  paid: String
  salary: String
  vendor_number: String
  voucher_field: Int
  voucher_number: String
  woker_name: String
}
type DailyCalendarOfficialExport {
  address: String
  cell_phone: String
  city: String
  comments: String
  duty: String
  email: String
  end_time: String
  event_date: String
  event_id: Int
  groupVal: String
  home_phone: String
  location: String
  offic_id: String
  opponent: String
  salary: String
  sport_description: String
  ssn: String
  start_time: String
  state: String
  vendor_number: String
  voucher_number: String
  woker_name: String
  work_phone: String
  zip: String
}
type DailyCalendarOfficialMessage {
  comments: String
  end_time: String
  event_date: String
  event_id: Int
  location: String
  official_duties: [DailyCalendarOfficialDuties]
  opponent: String
  sport: String
  start_time: String
}
type DailyCalendarPreparation {
  comments: String
  prep: String
  qty: String
}
type DailyCalendarPreparationExportData {
  comments: String
  end_time: String
  event_date: String
  event_id: Int
  groupval: String
  location: String
  opponent: String
  prep: String
  qty: String
  sport_description: String
  start_time: String
}
type DailyCalendarPreparationMessage {
  comments: String
  confirmed: String
  end_time: String
  event_date: String
  event_id: Int
  groupval: String
  location: String
  opponent: String
  place: String
  preparations: [DailyCalendarPreparation]
  sport: String
  start_time: String
}
type DailyCalendarWorkerDuties {
  SSN: String
  comments: String
  duty: String
  end_time: String
  event_date: String
  event_id: Int
  groupval: String
  location: String
  opponent: String
  organization: String
  paid: String
  pay_code: String
  phones: String
  salary: Float
  sport_description: String
  start_time: String
  woker_name: String
}
type DailyCalendarWorkerExportData {
  comments: String
  duty: String
  end_time: String
  event_date: String
  event_id: Int
  groupval: String
  location: String
  opponent: String
  pay_code: String
  phones: String
  sport_description: String
  start_time: String
  woker_name: String
}
type DailyCalendarWorkerMessage {
  comments: String
  end_time: String
  event_date: String
  event_id: Int
  groupval: String
  location: String
  opponent: String
  sport: String
  start_time: String
  worker_duties: [DailyCalendarWorkerDuties]
}
type DeleteCount {
  count: Int
}
type DeletedIncentiveRecord {
  id: ID!
}
type Deposit {
  amount: Decimal!
  campaignId: Int!
  created: Timestamp!
  description: String!
  destination: Account!
  effective: Timestamp!
  externalId: String!
  source: Account!
  transactionId: UUID!
}
"Documents uploaded for validation purposes"
type Document {
  documentBack: String
  documentFront: String
  gateway: VaultFinancialProvider!
  id: String!
  type: String!
  vaultKybId: ID
  vaultKycId: ID
}
"Not used yet. Will be removed soon."
type DonationInvite {
  email: String
  id: ID!
  lastEmailSentAt: String
  senderName: String
  status: String
}
type DonationInviteFollowUpEmail {
  id: Int!
}
type DonationInviteSMSData {
  id: Int!
  phoneNumber: String!
  status: String!
}
type DonationLevel {
  amount: Int!
  id: ID!
  level: DonationLevels!
  rewardDescription: String
  text: String
}
type DonationTopEarner {
  participantID: Int
}
"Donation Statistics. Will change name to CampaignDonationStats later."
type Donations {
  "Total of distinct donors in campaigns"
  AskedToShare: Int
  "Total count of donations in campaign"
  count: Int
  "Total donation amount in cents raised through email"
  emailTotal: Int
  "Total donation amount in cents raised other methods outside text, email and social"
  extraTotal: Int
  "Total of donation amount in cents raised through forward to friends."
  fowardTotal: Int
  "Total quantity of gear items purchased in campaign."
  gearAdded: Int
  "Total count of distinct donors that purchased gears."
  gearPurchased: Int
  "Total of purchase amount in cents of gear (OTK) items"
  gearTotal: Int
  "Total donation amounts in cents through retaining supporters from previous closed campaign. Share Type is 'reisgn_a' or 'resign_b'"
  legacySupporters: Int
  "Total count of distinct donors who are new and donated campaigns through share-type 'supporter_referral'"
  newSupporters: Int
  "Total count of donors who are retaining supporters from previous closed campaign. Share Type is 'reisgn_a' or 'resign_b'"
  pastSupporters: Int
  "Total donation amount in cents raised through social media"
  socialTotal: Int
  "Total donation amount in cents raised through sms/text"
  textTotal: Int
}
type DonorEmailAddresses {
  emails: [String]
}
type DonorEmailData {
  deliveryStatus: String
  emailAddress: String
  followUpNumber: Int
  id: Int
  personListEntryID: Int
}
type DonorPersonListEntry {
  email: String
  id: Int!
}
type DonorPhoneNumbers {
  phone: [String]
}
type DonorsParticipantOTKIncentive {
  description: String
  displayOrder: Int
  id: Int
  image: String
  name: String
  priceCents: Int
  purchaseLimit: Int
  purchased: Int
  size: String
}
type DonorsParticipantOTKIncentives {
  incentives: [DonorsParticipantOTKIncentive]
}
"Account User is a user that is registered in Raise's database. Deprecated: Use UserDirectory 's User instead instead"
type DriveAccountUser implements DriveUser {
  email: String
  firstName: String
  id: String!
  lastName: String
  phoneNumber: String
  profilePicture: String
  snapRaiseId: Int
}
"MDM Actor. e.g. Account Manager/Salereps/Sales Manager"
type DriveAmSalesReps {
  "Primary contact email of salesrep"
  email: String
  "End time of salesrep"
  endDate: DateTime
  "First Name of Salesrep"
  firstName: String
  "Last Name of Salesrep"
  lastName: String
  "Primary phone number of salesrep"
  phone: String
  "The sales manager of this salesrep"
  salesManager: DriveAmSalesReps
  "Salesrep Id. This is Raise's account user id."
  salesrepId: Int
  "Start time of salesrep"
  startDate: DateTime
  "actor type. e.g. 'salesrep', 'salesmanager', 'am'"
  type: String
}
"Information of a single drive campaign"
type DriveCampaign {
  "The account manager of the campaign"
  accountManager: AccountManager
  "@deprecated: not used, in favor of totalRaisedCents"
  donationRaisedCents: Int
  "The date the campaign ends"
  endDate: DateTime
  "The date the campaign has been finalized/closed"
  finalizedDate: DateTime
  "Indicate whether the campaign has any incentives, such as OTK"
  hasIncentive: Boolean
  id: Int!
  "Name of campaign"
  name: String
  "Notes for a campaign"
  notes: String
  "Url-slug of campaign name which is a unique identifier"
  slug: String
  "The date campaign starts"
  startDate: DateTime
  "Current status of campaign"
  status: CampaignStatus
  "The size of the team/group attached to campaign"
  teamSize: Int
  "@deprecated: not used, in favor of `totalRaisedCents`"
  totalRaised: BigInt
  "Total amount of donation of campaign in cents."
  totalRaisedCents: Int
}
"Campaign/Fundraiser details information. NOTE: In the future, we might merged with DriveCampaign or Campaign"
type DriveCampaignDetails {
  "Account Balance of campaign."
  accountBalance: AccountBalanceReturn
  "The activity/sport of this campaign, e.g. 'football', 'wrestling', etc."
  activityType: String
  "The amount in cents that campaigns was advanced in Wallet."
  advanceAmount: Int
  "Bill type when settled/finalized. Values are 'invoice', 'regular' and 'default'"
  billType: String
  "Credit Card Fee Payer. Values are 'customer' or 'snap'."
  ccFeePayer: String
  "Charge back fee in cents. The charge from payment processor when a donor cancels their donation through their bank instead of getting a refund from us directly. (usually $15 per)"
  chargebackFee: Int
  "The statistic of a donation of campaigns"
  donationStats: DriveCampaignDonationStats
  "The statistics of emails delivered/sent"
  emailDelivery: EmailsInfo
  "The type of snap fee being collected. e.g. 'standard', '1+1', '20%/15%', etc."
  feeType: String
  "Total incentives price in cents."
  gearCost: Int
  "Group leader of a campaign"
  groupLeader: DriveGroupLeader
  id: Int!
  "Cover Image for Campaign"
  image: String
  "Goal of how much a fundraiser wants to raise"
  initialGoalCents: Int
  "kyc processor. Values are 'wepay' or 'stripe'"
  kycProcessor: String
  "kyc status of a campaign. Values are 'pending', 'active', 'inactive', etc."
  kycStatus: String
  "The address to ship the check for this campaign"
  mailingAddress: String
  "The amount in cents that campaigns was manual-advanced in Raise."
  manualAdvanceAmount: Int
  "Net raised amount in cents. Equals totalRaised minus snapFee and adds the otkBonus. It is the amount client received in their check/deposit."
  netRaisedTotal: Int
  "Notes for settlement for this campaign"
  notes: String
  "The legal name of a fundraisers organization"
  organizationLegalName: String
  "The tin number of the organization"
  organizationTin: String
  "Total bonus amount of otk in cents"
  otkBonus: Int
  "The statistics of participants's activity of campaign"
  participantStats: DriveParticipantStats
  "Processing Fee when settled/finalized."
  processingFee: Int
  "The date where the campaign has settle its payments from snap"
  settlementDate: DateTime
  "How the funds has delivered to the organization. Values are 'check_fundraiser', 'check_salesrep', 'check_office' and 'direct_deposit'"
  settlementMethod: String
  "The amount in cents collected as fee when a campaign ends based of the fee type"
  snapFee: Float
  "Location of this fundraiser"
  territory: String
  "The amount of purchase in cents."
  totalPurchaseCents: Int
  "Total raised of a fundraiser"
  totalRaisedCents: Int
  "The total raised combined this organization has previously ran campaigns"
  totalRaisedHistory: Int
}
"Pulls data on a campaigns donation broken down"
type DriveCampaignDonationStats {
  ccCoverageAmountCents: Int
  donationAppFeeCents: Int
  "The amount that been raised"
  donationRaisedCents: Int
  "The total count of donations"
  donationsCount: Int
  offlineTotalCents: Int
  onlineTotalCents: Int
  "The count of participants"
  participantCount: Int
  "The donated amount in cents that been raised by emails delivered"
  totalEmailDonations: Int
  "The amount that been raised by miscellaneous forms"
  totalExtraDonations: Int
  "The donated amount that been raised by sharing through social media"
  totalSocialDonations: Int
  "The donated amount in cents that been raised by text message"
  totalTextDonations: Int
}
"Paginated list of campaigns"
type DriveCampaignList {
  "Total campaigns"
  count: Int
  list: [DriveCampaign]
  offset: Int
}
"Statistics for a set of campaigns in campaign-search."
type DriveCampaignSearchStatistics {
  avgDonationDollars: Float
  avgEmailsDelivered: Float
  avgEmailsPerParticipant: Float
  avgRaisedDollarsPerCampaign: Float
  avgRaisedDollarsPerEmail: Float
  avgTeamSize: Float
  totalCampaign: BigInt
  totalCountDelivered: BigInt
  totalCountParticpants: BigInt
  totalDonations: BigInt
  totalRaisedByEmail: Float
  totalRaisedDollars: Float
}
"Represents a Event object and its attributes"
type DriveEvent {
  "List of messages in the activity feed. Order by posted ascending by default."
  activityFeed: [DriveEventActivityFeed]
  "Activity types for an event. e.g. `football`, 'basketball', etc."
  activityTypes: [String!]
  "Event Agenda which include start-time/end-time of event dates. Should be empty is **agendaConfig.isSameTime** is true"
  agenda: [DriveEventAgendaItem!]
  """
  The configuration for agenda. Format as follows ```JSON { isSameTime: true, startTime: "09:00AM", endTime: "07:00PM" } ``` where **isSameTime** means all event dates will be occured at same **startTime** and **endTime**. If **isSameTime**, **startTime** and **endTime** should be filled-in
  """
  agendaConfig: JSON
  "List of attendees."
  attendees: [DriveEventAttendee!]
  "Booth information for an event."
  booth: DriveEventBooth
  "The user who is the clinic leader."
  clinicLeader: User
  "The user who created the event."
  createdBy: User
  "The description of an event."
  description: String
  "Indicator that event requires a door prize."
  doorPrizedRequired: Boolean
  "The end date of an event."
  endDate: String!
  "The hotel address for the attendees"
  hotelAddress: String
  "The hotel name for the attendees"
  hotelName: String
  "Url for hubspot link."
  hubspotTrackingLink: String
  id: ID!
  "Notes associated for the event."
  notes: String
  "A indicator whether the event had been completed planning phase."
  planningCompleted: Boolean
  "The time zone of an event"
  preferedTimezone: String
  "Description for the sponsorship"
  sponsorDescription: String
  "Indicator whether the door prize has been confirmed."
  sponsorDoorPrized: Boolean
  "The start date of an event."
  startDate: String!
  "The events status."
  status: DriveEventStatus!
  "The tier level for this event. Valid values is `1`, `2` and `3`"
  tier: Int
  "The name of the event."
  title: String!
  "Venue location information for an event."
  venue: DriveVenue
  "Website link for an event."
  websiteLink: String
}
"Information of a activity feed message"
type DriveEventActivityFeed {
  "A list of replies the message"
  children: [DriveEventActivityFeed]
  "The date this post was created"
  createdAt: DateTime
  "The event id"
  eventId: ID!
  "If the message is pinned to the top"
  featured: Boolean
  "The ID of the message"
  id: String!
  "The message posted"
  message: String
  "The date when this post has been updated"
  updatedAt: DateTime
  "A users first name and last and link to profile photo"
  user: User
  "The id of the user who posted the message"
  userId: ID!
}
"Attributes for an events agenda"
type DriveEventAgendaItem {
  description: String
  endTime: DateTime
  id: ID!
  location: String
  startTime: DateTime
  title: String
}
"Represents an events attendee attributes"
type DriveEventAttendee {
  "The department the attendee is in."
  department: String
  "The event ID"
  eventId: ID!
  "The status of an attendee flight request. Default is `NO_REQUEST`."
  flightRequest: EventAttendeeRequestStatus
  "The status of an attendee hotel request. Default is `NO_REQUEST`."
  hotelRequest: EventAttendeeRequestStatus
  id: ID! @deprecated(reason: "Use userId instead")
  "Indication whether this attendee a clinic leader."
  isClinicLeader: Boolean
  "The status of an attendee attendence."
  status: DriveAttendanceStatus!
  "User Information of attendee, includes `firstName`, `lastName`, `email`, etc. defined in UserDirectory."
  user: User
  "The udId of an attendee. e.g. `ud_abc123`"
  userId: ID!
}
"Booth attributes"
type DriveEventBooth {
  "Notes for the booth e.g. Electricity is paid for"
  boothNotes: String
  "The time to end breakdown or clean up event equipment in Venue."
  breakdownEndTime: DateTime
  "The time to start breakdown or clean up event equipment in Venue."
  breakdownStartTime: DateTime
  "Indication whether electricity is provided."
  electricityProvided: Boolean
  "Indication whether flooring is provided."
  flooringProvided: Boolean
  "Indication whether internet is provided."
  internetProvided: Boolean
  "The time to end setup for event"
  setupEndTime: DateTime
  "The time to begin setup for event"
  setupStartTime: DateTime
}
"Paginated list of drive events"
type DriveEventResults {
  events: [DriveEvent!]
  offset: Int
  totalCount: Int
}
"Organization Summary information used by Drive's Get List Application"
type DriveGetListOrganizationSummaryReturn {
  "Entity ID of the organization. Its purpose is for caching in Apollo Client."
  _id: Int @deprecated(reason: "use id")
  activitiesWithoutCampaigns: Int
  averageRaisedPerCampaign: Float
  campaignCompleted: Int
  city: String
  entityId: Int
  hubspotId: String
  id: String
  "Number of campaigns that completed of this Organization"
  name: String
  "Total students of the organization. Inherited from NCES data and studentCount from orgs-api."
  population: Int
  "Total potential raised in dollars for this organization. Equals NCES total students multiply with National RPK."
  potentialRaised: Float
  saturationPercent: Float @deprecated(reason: "use saturationPercentage")
  "Saturation percentage of organization. It is calculated by divide total logged-in students by NCES total students of this organization."
  saturationPercentage: Float
  state: String
  "Lifetime total raised in dollars of organization. Computed from all non-upcoming campaigns."
  totalRaised: Float
  "Lifetime total raised in cents of organization."
  totalRaisedCents: Int
  type: String
}
type DriveGetlistProspectsReturn {
  offset: Int
  results: [HubspotProspectsDeals]
  totalCount: Int
}
type DriveGetlistWinbackReturn {
  offset: Int
  results: [WinbackDeals]
  totalCount: Int
}
"Group Leader information in Drive"
type DriveGroupLeader {
  "The full name of the group leader"
  name: String
}
type DriveOrgListResults {
  offset: Int
  orgs: [DriveGetListOrganizationSummaryReturn]
  totalCount: Int
}
"Organization used by Drive"
type DriveOrganization {
  activity: String
  city: String
  id: Int
  legalName: String
  name: String
  state: String
}
"List of organizations used by Drive"
type DriveOrganizationList {
  list: [DriveOrganization]!
  offset: Int
}
"Statistics information related to Participants in one campaign"
type DriveParticipantStats {
  "Count of participants who had logged in"
  loggedInCount: Int
  "Count of participants with 20 emails sent"
  participantsWithAtLeastTwentyEmails: Int
  "Percentage of active participants of campaign."
  participationPercent: Int
  "Count of participants with at least one donation"
  withAtLeastOneDonation: Int
}
type DriveUsersResult {
  nextPage: Boolean
  users: [DriveAccountUser]
}
"Venue or location for Event used by Event Clinic"
type DriveVenue {
  "Building name or Room number. e.g. `Room 330`"
  buildingOrRoom: String
  "City of Venue location, e.g. `Dallas`"
  city: String
  id: ID!
  "Venue Name. e.g. `Hillton Convention Center`, e.g."
  name: String!
  "The short-code for US States. e.g. `TX`, 'CA'"
  state: String
}
"Information of a emails for a camapgin"
type EmailsInfo {
  "Total emails bounced back due to failed delivery"
  bounced: Int
  "Total emails loaded by particpants"
  loaded: Int
  "The schedule (timezone-sensitive) thatthe emails are scheduled to release"
  scheduledReleaseDate: ScheduledReleaseInfo
  "Total emails sent"
  sent: Int
  "The datetime the emails were sent out"
  sentAt: DateTime
}
type Event {
  activity: String
  activityLevel: String
  activityType: String
  author: String
  bus_fee: Float
  bus_time: String
  cancellation_status: String
  comments: String
  conference: String
  conference_event_id: Int
  conference_id: Int
  confirmed: String
  confirmedStatusBoolean: Boolean
  contract: String
  created_at: Date
  departure_location: String
  directions: String
  early_dismissal_required: String
  early_dismissal_time: String
  end_time: String
  estimated_return_time: String
  event: String
  eventOfficials: [Official]
  eventTiming: String
  event_date: Date
  event_id: Int!
  exists_in_mls: Int
  fee: Float
  formattedEventDate: String
  formattedEventDateSystem: String
  formattedEventDay: String
  g_s: String
  gate_revenue: Float
  groupval: String
  headline: String
  impact_event: String
  isDuplicate: Boolean
  lead: String
  location: String
  loss_points: Int
  num_buses: Int
  opponent: String
  opponent_code: String
  opponent_score: String
  picture: String
  place: String
  prep_setup: String
  promote: String
  results: String
  revenue: Float
  rollover: String
  rolloverStatusBoolean: Boolean
  seasonInfo: String
  seasonSportCode: String
  season_team: Int
  sportCode: String
  sportDescription: String
  sportGender: String
  sportLevel: String
  sportName: String
  start_time: String
  team_score: String
  title: String
  tournament: String
  trans_id: Int
  transportDetails: String
  transport_comments: String
  transportation: String
  update_at: Date
  vehicle_count: Int
  web_dir: String
  weekdayname: String
  win_points: Int
  years: String
}
type EventContract {
  comments: String
  event_contract_number: Int
  id: Int
  main_event_id: Int
  participant: String
  signee_name: String
  signees: [ContractSignees]
  years: String
}
type EventOfficialReport {
  comments: String
  event_id: String
  facility: String
  officials: [EventOfficials]
  opponent: String
  team: String
}
type EventOfficials {
  address: String
  cell_phone: String
  city: String
  duty: String
  email: String
  first_name: String
  home_phone: String
  last_name: String
  official_id: String
  paid: String
  pay_code: String
  received: String
  salary: Float
  ssn: String
  work_phone: String
  zip: String
}
type EventParticipants {
  SchoolName: String
  contract_received: String
  event_id: Int
  id: Int!
  notes: String
  paid: String
  school_code: String
}
type EventPreparations {
  comments: String
  event: Int
  id: Int!
  prep: String
  qty: String
}
type EventTransportDetails {
  driver_name: String
  driver_phone: String
  event_date: Date
  event_id: Int
  id: Int!
  vehicle_id: String
  vehicle_type: String
}
type EventTransportDetailsDeleteManyCount {
  count: Int
}
type EventsOpponent {
  activity: String
  confirmed: String
  end_time: String
  eventId: Int
  event_date: Date
  eventsOpponentId: Int
  season_years: String
  start_time: String
}
type ExportFile {
  content: String
  fileName: String
}
type ExternalBankAccount {
  accountId: String!
  accountType: AccountType
  bankName: String!
  campaignId: String!
  last4: String!
}
type Facility {
  Address1: String
  Address2: String
  City: String
  Date: Date
  Facility_id: Int
  State: String
  ZipCode: String
  directions: String
  indoor: String
  is_deleted: Boolean
  location_id: Int
  ml_site_id: Int
  ml_space: String
  ml_space_id: Int
  picture: String
  place_name: String!
  show: String
  specialDirections: String
  web: String
}
type FacilityLocation {
  Address1: String
  Address2: String
  City: String
  State: String
  ZipCode: String
  directions: String
  location_id: Int
  place_name: String
}
type Family {
  children: [User]
  parents: [User]
}
type FinancialAcctNode {
  acctId: ID
  applicationId: ID
  createdAt: DateTime
  customerId: ID
  finAcctId: ID
  kybId: ID
  orgId: ID
  orgName: String
  processor: Processor
  status: FinAcctStatus
  updatedAt: DateTime
}
type FinancialAcctUser {
  acctId: ID
  applicationId: ID
  customerId: ID
  finAcctId: ID
  isBeneficialOwner: Boolean
  isContact: Boolean
  isPrincipal: Boolean
  isRepresentative: Boolean
  kybId: ID
  kycId: ID
  orgId: ID
  personId: ID
  processor: Processor
  status: FinAcctStatus
  userId: ID
}
type FinancialAddress {
  city: String
  line1: String
  line2: String
  state: String
  zip: String
}
type Fundraiser {
  description: String
  endDate: String
  goal: Int
  groupName: String
  id: ID!
  name: String!
  netRaised: Int
  organization: Organization
  prefund: Prefund
  salesRep: String
  slug: String
  startDate: String
  status: FUNDRAISER_STATUS
  totalRaised: Int
}
type FundraiserCheerwall {
  cheers: [Cheer]
  count: Int
}
type FundraiserDonations {
  count: Int
  donations: [CheerWall]
}
type FundraiserEntityResource {
  entityId: Int
}
type FundraiserGroup {
  id: ID!
  label: String
}
type FundraiserList {
  hasMore: Boolean
  list: [Fundraiser!]!
}
type FundraiserRaisedAmount {
  subtotalCents: Int
}
type FundraiserRewardLevelsCount {
  levelsCount: Int
}
type FundraiserRewardsProduct {
  default: Boolean
  fitting: String
  id: Int
  image: String
  name: String
  sizes: String
  tier: Int
}
type FundraiserTopDonation {
  donorName: String
  subtotalCents: Int
}
type FundraiserUserIncentiveID {
  id: Int
}
type FundraiserUserRole {
  isGroupLeader: Boolean
  isParticipant: Boolean
  roles: [String]
}
type GalleryItems {
  campaignLogo: String
  campaignLogoThumb: String
  carouselItems: [CarouselItem]
}
type GroupLeader {
  email: String
  id: ID!
  name: String
  phone: String
}
"See CampaignMembership for details"
type GroupLeaderCampaign {
  basicStatus: BasicCampaignStatus!
  donationLink: String!
  goalInDollars: Int
  id: ID!
  isCocoach: Boolean!
  joinCode: String
  "Getting Kyc status adds time to your query **expensive**"
  kyc: CampaignKyc
  name: String!
  "Primary group leader"
  primary: PrimaryGroupLeader
  "Getting roster adds time to your query"
  roster: [Roster]
  status: CampaignStatus!
  teamSize: Int
  totalCentsRaised: Int
  whyDonateText: String
}
type GroupLeaderList {
  count: Int
  cursor: String
  list: [GroupLeader]!
}
type GroupsOverviewDashboardResponse {
  overview: [SpendGroupsOverview]
}
type HmAccountRole {
  account_id: Int
  id: String!
  role_id: Int
}
type HmGraphSales {
  soldDuringWeek: Int
  weekName: String
}
type HmSalesRep {
  rep_email: String
  sales_rep: String
}
type HmSpendAccount {
  id: Int
  orgTeamMembers: [String]
}
type HmSpendData {
  credited: Int
  inactiveCards: Int
  paid: Int
  pastDue: Int
  pending: Int
  upcoming: Int
}
type HmSponsorData {
  activeSponsorships: Int
  assetCount: Int
  available: Int
  sponsorShipValue: Int
  totalAssets: Int
}
type HmStore {
  active_stores: String
  monthly_sales: [HmGraphSales]
  total_orders: String
  total_points: String
  total_sales: String
}
type HmUser {
  email: String
  id: Int!
  name: String
}
"Hubspot Engagement entity"
type HubspotCallEngagement {
  contactIds: [String]
  dealIds: [String]
  engagementId: String
  ownerId: String
  type: String
}
type HubspotProspectsDeals {
  activity: String
  dealName: String
  dealStage: String
  id: String
  isProspectPinned: Boolean
  lastActivityDate: String
  leaderFirstName: String
  leaderLastName: String
  projectedLaunchDate: String
}
"Common payload for mutations."
type IMutationResult {
  data: JSON
  message: String
}
type Industry {
  id: String
  isActive: Boolean
  name: String
}
type InsAddPreApprovedContactsResult {
  contactsResult: [InsPreApprovedContactResult]
  errors: [String]
  status: String!
}
type InsAnalyticsSummaryStat {
  amount_raised_cents: Int!
  campaign_id: Int!
  month: Int!
  year: Int!
}
type InsCampaignDonation {
  amount_cents: Int
  campaign_id: Int!
  campaign_name: String
  created_at: DateTime
  donor_name: String
  id: Int!
  participant_name: String
}
type InsCampaignRaiseEntityInfo {
  campaign_id: Int!
  entity_id: Int
}
type InsCampaignSettlement {
  amount_cents: Int
  campaign_id: Int!
  campaign_name: String
  id: Int!
  last_updated: DateTime
  method: String
  status: String
}
type InsCampaignStat {
  donations_count: Int
  end_date: DateTime
  forecasted_amount_cents: Int
  group_leader_email: String
  group_leader_name: String
  id: Int!
  insights_status: String
  name: String
  participants: Int
  participation: Float
  preloading: Float
  start_date: DateTime
  total_raised_cents: Int
}
type InsCampaignsData {
  analyticsSummaryStats: [InsAnalyticsSummaryStat]
  campaignStats: [InsCampaignStat]
  donationMapStats: [InsDonationMapStat]
  inviteStats: [InsInviteStat]
  lTRChart: InsLTRChartData
  monthlyCampaignStats: [InsMonthlyCampaignStat]
}
type InsDeletePreApprovedContactResult {
  errors: [String]
  status: String!
}
type InsDonationMapStat {
  campaign_id: Int
  campaign_ids: [Int]
  donations_amount_cents: Int
  donations_count: Int
  lat: Float
  long: Float
  postal_code: String
}
type InsDonorParticipantContact {
  campaign_id: Int!
  donor_email: String
  donor_id: Int
  donor_name: String
  participant_email: String
  participant_id: Int
  participant_name: String
}
type InsEditPreApprovedContactResult {
  error: String
  status: String!
}
type InsEditPreApprovedInvite {
  activity: String!
  email: String!
  firstName: String!
  inviteStatus: String!
  lastName: String!
  orgName: String!
}
type InsEditPreApprovedInviteResult {
  errors: [String]
  status: String!
  updatedInvite: InsEditPreApprovedInvite
}
type InsEmailTestPreApprovedContactResult {
  email: String!
  status: String!
}
type InsInviteStat {
  campaign_id: Int
  campaign_ids: [Int]
  invite_count: Int!
  invite_type: String!
  total_amount_cents: Int!
}
type InsLTRChartData {
  activeCampaignsCount: Int
  activeCampaignsParticipation: Float
  activeCampaignsTotalCents: Int
  avgDonationCents: Int
  closedCampaignsCount: Int
  closedCampaignsParticipation: Float
  closedCampaignsTotalCents: Int
  ltr: Int
  upcomingCampaignsCount: Int
  upcomingCampaignsForecastedAmountCents: Int
  upcomingCampaignsParticipantSignIn: Float
}
type InsMonthlyCampaignStat {
  campaign_ids: [Int]!
  month: Int!
  participation: Float
  preloading: Float
  year: Int!
}
type InsOrg {
  id: Int!
  name: String
}
type InsOrgCampaignSummary {
  campaignsCount: Int!
  orgId: String
  totalRaisedCents: Int!
}
type InsPreApprovedContact {
  activity: String
  associated_org_id: String
  associated_org_name: String
  email: String
  first_name: String
  id: Int
  invite_sent_at: DateTime
  invite_status: String
  last_name: String
}
type InsPreApprovedContactResult {
  email: String!
  status: String!
}
type InsResendPreApprovedContactResult {
  errors: [String]
  status: String!
}
type InsSalesRepInfo {
  email: String!
  featured_image: String
  hubspot_calendar_link: String
  phone_number: String
  post_title: String
}
type InsUser {
  id: Int!
}
type InsightsUserPreference {
  campaign_raise_id: Int
  hidden: Boolean
  org_id: String
  user_id: String
}
type InsightsUserPreferencesCreateResult {
  errors: [String]
  status: String
}
type InsightsUserPreferencesUpdateResult {
  errors: [String]
  status: String
}
type Invite {
  assignedAt: String
  business: String
  createdAt: String
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  status: String
  updatedAt: String
}
type InviteInfo {
  email: String
  flow: String
  flowParams: JSONObject
  joincode: String
  requester: User
  status: String
}
type InviteList {
  acceptedAt: String
  createdAt: String
  email: String
  expiresAt: String
  id: String
  joincode: String
  requester: User
  status: UserInviteStatus
}
type Invites {
  invites: [Invite]
  totalCount: Int
}
type JoinedFundraiserID {
  "Returns the ID of the fundraiser"
  id: Int
}
type Level {
  ID: Int!
  Level: String
  is_deleted: Boolean
}
type Link {
  dest: String
  name: String
  source: String
}
type Links {
  dest: String
  name: String
  source: String
}
type MDMDetails implements DriveUser {
  email: String
  firstName: String
  lastName: String
  phone: String
}
type MagentoOrder {
  baseDiscountAmount: Float
  baseGrandTotal: Float
  baseShippingAmount: Float
  baseSubtotal: Float
  baseTaxAmount: Float
  createdAt: ID
  customerEmail: String
  customerFirstName: String
  customerLastName: String
  discountAmount: Float
  grandTotal: Float
  incrementId: String
  items: [OrderItem]
  mageworxRewardPointsAmount: Float
  orderId: BigInt
  scopeId: BigInt
  shippingAmount: Float
  state: String
  status: String
  storeDashbordStatus: String
  subtotal: Float
  taxAmount: Float
  totalPaid: Float
  updatedAt: String
}
type MagentoOrders {
  orders: [MagentoOrder]
}
type MagentoPointActivities {
  activities: [MagentoPointActivity]
}
type MagentoPointActivity {
  createdAt: String
  customerId: BigInt
  customerName: String
  pointsBalance: Float
  pointsDelta: Float
  scopeId: BigInt
  status: String
  storeCode: String
  storeName: String
  teamName: String
  transactionId: BigInt
  transactionType: String
}
type MagentoStore {
  accountManagerId: String
  activityType: String
  baseTotalSales: Float
  brands: [Brand]
  campaignId: Int
  city: String
  code: String
  digitalLogo: String
  domain: String
  email: String
  embroideryLogo: String
  enabled: Int
  entityId: BigInt
  favicon: String
  groupLeaderEmail: String
  hatLogo: String
  headerLogo: String
  heroSliderVariableId: BigInt
  homepagePageId: String
  managerId: BigInt
  name: String
  ncesId: String
  orgId: Int
  organizationName: String
  parentStoreId: Int
  pointsPercentage: Int
  primaryColor: String
  productColors: [ScopeProductColor]
  programId: Int
  raiseId: Int
  salesRepId: String
  secondaryColor: String
  state: String
  status: String
  storeId: BigInt
  storevariablesId: BigInt
  teamName: String
  totalOrders: BigInt
  totalPoints: Float
  totalSales: Float
  zipCode: Int
}
type MagentoStoreManager {
  email: String
  firstName: String
  groupId: Int
  lastName: String
  managerId: BigInt
  points: Float
  scopeId: BigInt
}
type MagentoStorePointsEarned {
  endDate: String
  startDate: String
  totalPoints: Float
}
type MagentoStoresPointsEarned {
  points: [MagentoStorePointsEarned]
}
"The object which contains all the input data for the ManageResource announcement query"
type ManageAnnouncement {
  active: String
  announcement: String
  createdAt: Date
  createdBy: Int
  emailFilter: String
  emailRequest: Int
  endDate: Date
  id: Int
  imageId: Int
  isApproved: Boolean
  onFront: Int
  recordStatus: Int
  schoolId: Int
  showUrgentFrom: Date
  showUrgentUntil: Date
  sortVal: Int
  sport: String
  sportName: String
  startDate: Date
  title: String
  updatedAt: Date
  updatedBy: Int
  urgent: Boolean
}
type ManageAnnouncementList {
  count: Int
  list: [ManageAnnouncement]
  skip: Int
  take: Int
}
type ManageCoach {
  "Associated Ad ID for the coach."
  adId: Int
  "Unique ID of the coach."
  coachId: Int
  "Timestamp when the coach was created."
  createdAt: Date
  "ID of the user who created the coach entry."
  createdBy: Int
  "First name of the coach."
  firstName: String
  "Indicates if the coach is a head coach."
  headCoach: Boolean
  "Indicates if the coach is approved."
  isApproved: Boolean
  "Last name of the coach."
  lastName: String
  "ID for the coach's photo."
  photoId: Int
  "School's unique ID associated with the coach."
  schoolId: Int
  "ID of the coaching season."
  seasonId: Int
  "Brief description or profile of the coach."
  summary: String
  "Title or position of the coach."
  title: String
  "Timestamp when the coach was last updated."
  updatedAt: Date
  "ID of the user who last updated the coach entry."
  updatedBy: Int
}
type ManageCoachList {
  "Total count of coaches that match the criteria."
  count: Int
  "The list of coaches."
  list: [ManageCoach]
  "Number of coaches skipped."
  skip: Int
  "Number of coaches fetched."
  take: Int
}
type ManageEvent {
  "Type of activity or sport."
  activity: String
  "Author or writer of the event story."
  author: String
  "Fee associated with transportation or bus."
  busFee: Int
  "Scheduled time for the bus or transportation."
  busTime: String
  "Status indicating event's cancellation."
  cancellationStatus: String
  "Additional comments or notes."
  comments: String
  "Conference details or name."
  conference: String
  "Event ID related to the conference."
  conferenceEventId: Int
  "ID associated with the conference."
  conferenceId: Int
  "Confirmation status of the event."
  confirmed: String
  "Contract details or identifier."
  contract: String
  "Timestamp when the event was created."
  createdAt: Date
  "Timestamp when the event result was created."
  createdResultAt: String
  "User ID of the creator of the event result."
  createdResultBy: Int
  "Location for event departure."
  departureLocation: String
  "Link for directions or map."
  directionLink: String
  "Directions or map details for the event."
  directions: String
  "Indication if early dismissal is required."
  earlyDismissalRequired: String
  "Scheduled time for early dismissal."
  earlyDismissalTime: String
  "End time of the event."
  endTime: String
  "Estimated time of return post event."
  estimatedReturnTime: String
  "Indication if the event is complete."
  eventComplete: Int
  "Date of the event."
  eventDate: Date
  "Date and Time for start of event."
  eventDateTime: String
  "Calculated field from event date indicating day of the week."
  eventDay: String
  "Calculated field from event ID for event details."
  eventDetailsPath: String
  "The unique ID of the event."
  eventId: Int
  "Lead or main summary of the event."
  eventLead: String
  "Unique ID for the event result."
  eventResultID: Int
  "Detailed story or description of the event."
  eventStory: String
  "Title or main heading of the event story."
  eventTitle: String
  "Type or category of the event."
  eventType: String
  "Indication if event exists in MLS system."
  existsInMls: Int
  "Fee or cost associated with the event."
  fee: Int
  "Revenue generated from gate or entry fee."
  gateRevenue: Int
  "Gender specification for the event."
  gender: String
  "Value grouping multiple events."
  groupVal: String
  "General status of the event."
  gs: String
  "Main headline or caption for the event."
  headline: String
  "Indication if the event has major impact."
  impactEvent: String
  "Indication if event details are approved."
  isApproved: Boolean
  "Lead information or summary."
  lead: String
  "Level of the event."
  level: String
  "Location description or address."
  location: String
  "Points deducted for a loss."
  lossPoints: Int
  "Number of buses or transportation units."
  numBuses: Int
  "Name or description of the opponent."
  opponent: String
  "Code identifier for the opponent."
  opponentCode: String
  "Opponent details or description."
  opponentForEvent: ManageOpponent
  "Score achieved by the opponent team."
  opponentScore: String
  "Outcome or result of the event."
  outcome: String
  "URL or path to event picture."
  picture: String
  "Location or venue of the event."
  place: String
  "Details for event setup or preparation."
  prepSetup: String
  "Indication if event should be promoted."
  promote: String
  "Indication if score should be reported."
  reportScore: Int
  "Indication if story related to event should be reported."
  reportStory: Int
  "Results or outcomes from the event."
  results: String
  "Total revenue generated from the event."
  revenue: Int
  "Indication if event rolls over to next season."
  rollover: String
  "Season details or year."
  season: String
  "Associated team for the season."
  seasonTeam: Int
  "Indication if event should be showcased on front page."
  showFrontPage: Int
  "Start time used for sorting."
  sortStartTime: String
  "Start time of the event."
  startTime: String
  "Name of the associated team."
  teamName: String
  "Score achieved by the home team."
  teamScore: String
  "Title or heading of the event."
  title: String
  "Indication if the event is part of a tournament."
  tournament: String
  "Unique ID for transportation details."
  transId: Int
  "Comments related to transportation."
  transportComments: String
  "Transportation details for the event."
  transportation: String
  "Date when event result was last updated."
  updateResultDate: String
  "Timestamp of the last update to the event."
  updatedAt: Date
  "Timestamp of the last update to the event result."
  updatedResultAt: String
  "User ID of the last updater of the event result."
  updatedResultBy: Int
  "Web directory or path for the event."
  webDir: String
  "Points awarded for a win."
  winPoints: Int
  "Year(s) associated with the event."
  years: String
}
"Represents a paginated list of events."
type ManageEventList {
  "A formatted date for calendar display purposes."
  calendarDate: String
  "Total count of events that match the criteria."
  count: Int
  "The list of events."
  list: [ManageEvent]
  "Number of items skipped."
  skip: Int
  "Number of items fetched."
  take: Int
}
"The object which contains all the input data for the ManageFacility query"
type ManageFacility {
  directions: String
  indoor: String
  isDeleted: Boolean
  locationId: Int
  mlSiteId: Int
  mlSpace: String
  mlSpaceId: Int
  picture: String
  placeName: String
  show: String
  web: String
}
type ManageFacilityList {
  count: Int
  list: [ManageFacility]
  skip: Int
  take: Int
}
"The object which contains all the input data for the ManageHeadline query"
type ManageHeadline {
  eventResultId: Int
  eventStory: String
  eventTitle: String
  refId: Int
}
type ManageHeadlineList {
  count: Int
  list: [ManageHeadline]
  skip: Int
  take: Int
}
"A type representing details about an opponent in the context of school management."
type ManageOpponent {
  "The name of the athletic director (AD) associated with the school/opponent."
  adName: String
  "The physical address of the school."
  address: String
  "The city where the school is located."
  city: String
  "The primary contact email address for the school."
  email: String
  "The fax number for the school, if available."
  fax: String
  "A flag indicating if the opponent's record has been marked as deleted."
  isDeleted: Boolean
  "The National Center for Education Statistics (NCES) identifier for the school."
  ncesId: String
  "A flag indicating if the entity is not an actual school."
  nonSchool: Boolean
  "The primary contact phone number for the school."
  phone: String
  "The unique identifier for the school. This is mandatory."
  schoolCode: String!
  "The official name of the school."
  schoolName: String
  "The state or province where the school is located."
  state: String
  "The postal code for the school's address."
  zip: String
}
"The object which contains all the input data for the manage organization query"
type ManageOrganization {
  "The ad of the school"
  ad: String
  "AD Program ID"
  adProgramID: Int
  "Ad report"
  adReport: Int
  "The ad school of the school"
  adSchool: Int
  "The address of the school"
  address: String
  "Announcements for the organization"
  announcementsForOrganization(filter: ManageAnnouncementFilter): ManageAnnouncementList
  "AOTM Spotlight"
  aotmSpotlight: Int
  "Auto Approve Score Only"
  autoApproveScoreOnly: Int
  "Camp Registration Confirmation Text"
  campRegConfirmationTxt: String
  "The city of the school"
  city: String
  "The list of coaches for this organization"
  coachForOrganization(filter: ManageCoachListFilter): ManageCoachList
  "The First Color of the school"
  color1: String
  "The Second Color of the school"
  color2: String
  "Conference Name"
  conferenceName: String
  "Conference URL"
  conferenceURL: String
  "Custom Label"
  customLabel: String
  "Custom Label 2"
  customLabel2: String
  "Custom Link"
  customLink: String
  "Custom Link 2"
  customLink2: String
  "The Database folder of the school"
  dbFolder: String
  "Email Blast Enabled"
  emailBlastEnabled: Int
  "Email Spotlight"
  emailSpotlight: Int
  "Equipment Enabled"
  equipmentEnabled: Boolean
  "Event Locations for the organization"
  eventLocationsForOrganization(filter: ManageResourceLinkFilter): ManageResourceLinkList
  "Facebook Url"
  facebookUrl: String
  "Facilities for the Organization"
  facilitiesForOrganization(filter: ManageFacilityFilter): ManageFacilityList
  "The fax number of the school"
  fax: String
  "The featured of the school"
  featured: Int
  "Feeders Towns for the school"
  feederTowns: String
  "Gallery Spotlight"
  gallerySpotlight: Int
  "Has Activities"
  hasActivities: Boolean
  "Has Access OTM"
  hasAotm: Boolean
  "Has Athletics"
  hasAthletics: Boolean
  "Has Email Blast"
  hasEmailBlast: String
  "Has Facebook Url"
  hasFacebookUrl: Boolean
  "Has Instagram Url"
  hasInstagramUrl: Boolean
  "Has Migrated From Access To Sql Server"
  hasMigratedFromAccessToSqlServer: Boolean
  "Has Registration"
  hasRegistration: Boolean
  "Has Twitter Url"
  hasTwitterUrl: Boolean
  "Headlines for the Organization"
  headlinesForOrganization(filter: ManageHeadlineFilter): ManageHeadlineList
  "The icon of the school"
  iCon: String
  "Instagram Url"
  instagramUrl: String
  "League Keeper school id"
  lKschoolId: Int
  "The latitude of the school"
  lat: Float
  "The id of the link to school database"
  linkSchoolId: Int
  "The logo of the school"
  logo: String
  "The longitude of the school"
  long: Float
  "The mascot of the school"
  mascot: String
  "Does the school have email updates"
  massUpdate: Int
  "Master School Id"
  masterSchoolId: Int
  "The message of the school"
  message: String
  "Motto"
  motto: String
  "Old School Id"
  oldSchoolId: Int
  "Pages for the organization"
  pagesForOrganization(filter: ManagePagesFilter): ManagePagesList
  "The url path for the school"
  path: String
  "The phone number of the school"
  phone: String
  "Photos for the Organization"
  photosForOrganization(filter: ManagePhotosFilter): ManagePhotosList
  "The list of players for this organization"
  playersForOrganization(filter: ManagePlayerListFilter): ManagePlayerList
  "The principal of the school"
  principal: String
  programsForOrganization(filter: ManageProgramListFilter): ManageProgramList
  "PS School Id"
  psSchoolId: String
  "PS Store Active"
  psStoreActive: Int
  "The Registration Email of the school"
  registrationEmail: String
  "The Registration Enabled of the school"
  registrationEnabled: Int
  "The Registration Policy of the school"
  registrationPolicy: String
  "The Registration Type of the school"
  registrationType: Int
  "The id of the school"
  schoolId: Int
  "The name of the school"
  schoolName: String
  "The show of the school"
  show: Int
  "Show Ad"
  showAd: Boolean
  "Show School Name And Motto"
  showSchoolNameAndMotto: Boolean
  "Do you want to show the teams pages first on the site"
  showTeamPagesFirst: Int
  "A Sign up code for the school"
  signUpCode: String
  "The site type of the school"
  siteType: String
  "Sport Registration Confirmation Text"
  sportRegConfirmationTxt: String
  "The id of the sql database"
  sqlBase: Int
  "Staff Calendar Enabled"
  staffCalendarEnabled: Int
  "The state of the school (abbreviation)"
  state: String
  "The state organization of the school"
  stateOrg: String
  "Time Zone"
  timeZone: String
  "Twitter Url"
  twitterUrl: String
  "Urgent Announcements for the organization"
  urgentAnnouncementsForOrganization(filter: UrgentAnnouncementFilter): ManageAnnouncementList
  "The web folder of the school that you have chosen"
  webFolder: String
  "Web Password"
  webPassword: String
  "The website of the school"
  webSite: String
  "The zip code of the school"
  zip: String
}
type ManageOrganizationList {
  "Total count of organizations that match the criteria."
  count: Int
  "The list of organizations."
  list: [ManageOrganization]
  "Number of organizations skipped."
  skip: Int
  "Number of organizations fetched."
  take: Int
}
"The object which contains all the input data for the ManageResource Pages query"
type ManagePages {
  createdAt: Date
  createdBy: Int
  id: Int
  name: String
  pageContent: String
  pageTitle: String
  schoolId: Int
  updatedAt: Date
  updatedBy: Int
}
type ManagePagesList {
  count: Int
  list: [ManagePages]
  skip: Int
  take: Int
}
"The object which contains all the input data for the ManageResource photos query"
type ManagePhotos {
  batch: String
  caption: String
  companyId: Int
  createdAt: Date
  createdBy: Int
  filename: String
  group: String
  id: Int
  image: Buffer
  layout: String
  level: String
  needsApproval: Int
  projectId: Int
  recordStatus: Int
  rphoto: Int
  school: Int
  sport: String
  src: String
  title: String
  updatedAt: Date
  updatedBy: Int
}
type ManagePhotosList {
  count: Int
  list: [ManagePhotos]
  skip: Int
  take: Int
}
"The object which contains all the input data for each player"
type ManagePlayer {
  ch1: Int
  ch2: Int
  ch3: Int
  city: String
  custodyCode: Int
  dayPhone: String
  dob: Date
  fName: String
  feePaid: Int
  gender: String
  gradYear: String
  hatsize: String
  height: String
  homePhone: String
  hospitalPhone: String
  insuranceCompany: String
  insurancePolicyNum: String
  jersey: String
  lName: String
  livesWithCode: Int
  noPress: Int
  participantId: Int
  permission: Int
  physical: Int
  physicalDate: Date
  physician: String
  physicianTelephone: String
  position: String
  preferredHospital: String
  rosterId: Int
  schoolId: Int
  seasonId: Int
  shirtsize: String
  shortsize: String
  sortJersey: Int
  stAddress: String
  state: String
  status: String
  studentId: String
  weight: String
  zip: String
}
type ManagePlayerList {
  count: Int
  list: [ManagePlayer]
  skip: Int
  take: Int
}
type ManageProgram {
  "Announcements for the program"
  announcementsForPrograms(filter: ManageAnnouncementFilter): ManageAnnouncementList
  gender: String
  groupVal: String
  homeField: String
  id: Int
  level1: String
  "Photos for the program"
  photosForPrograms(filter: ManagePhotosFilter): ManagePhotosList
  "Links for the program"
  resourceLinksForPrograms(filter: ManageResourceLinkFilter): ManageResourceLinkList
  seasonsForProgram(filter: ManageSeasonListFilter): ManageSeasonList
  sportCode: String
  sportDescription: String
  sportDetailsForProgram(filter: ManageSportDetailsListFilter): ManageSportDetailsList
  sportName: String
  "Team Stats for the program"
  teamStatsForPrograms(filter: ManageTeamStatsFilter): ManageTeamStatsList
}
type ManageProgramList {
  count: Int
  list: [ManageProgram]
  skip: Int
  take: Int
}
"The object which contains all the input data for the ManageResource event location query"
type ManageResourceLink {
  "The fileName for the event location"
  fileName: String
  "The filename link for the event location"
  fileNameLink: String
  "The sport gender and level for the event location"
  gVal: String
  "The id for the event location"
  id: Int
  "The isApproved for the event location"
  isApproved: Int
  "The type for the event location"
  lType: String
  "The link for the event location"
  link: String
  "The name for the event location"
  name: String
  "The onFornt for the event location"
  onFront: Int
  "The recordStatus for the event location"
  recordStatus: Int
  "The school id for the event location"
  schoolNum: Int
  "The sortOrder for the event location"
  sortOrder: Int
}
type ManageResourceLinkList {
  count: Int
  list: [ManageResourceLink]
  skip: Int
  take: Int
}
"The object which contains all the input data for each player"
type ManageRoster {
  ch1: Int
  ch2: Int
  ch3: Int
  city: String
  custodyCode: Int
  dayPhone: String
  dob: Date
  fName: String
  feePaid: Int
  gender: String
  gradYear: String
  hatsize: String
  height: String
  homePhone: String
  hospitalPhone: String
  insuranceCompany: String
  insurancePolicyNum: String
  jersey: String
  lName: String
  livesWithCode: Int
  noPress: Int
  participantId: Int
  permission: Int
  physical: Int
  physicalDate: Date
  physician: String
  physicianTelephone: String
  position: String
  preferredHospital: String
  rosterId: Int
  schoolId: Int
  seasonId: Int
  shirtsize: String
  shortsize: String
  sortJersey: Int
  stAddress: String
  state: String
  status: String
  studentId: String
  weight: String
  zip: String
}
type ManageRosterList {
  count: Int
  list: [ManageRoster]
  skip: Int
  take: Int
}
type ManageSeason {
  budget: Float
  coachForProgramSeason(filter: ManageCoachListFilter): ManageCoachList
  defaultTimeForEvent: String
  defaultTimeForPractice: String
  "The events for the season."
  eventsForSeason(filter: ManageEventListFilter): ManageEventList
  homeField: String
  isDeleted: Boolean
  playersForProgramSeason(filter: ManagePlayerListFilter): ManagePlayerList
  preview: String
  rosterForProgramSeason: ManageRosterList
  season: String
  seasonId: Int
  sportCode: String
  "The upcoming events for the season."
  upcomingEventsForSeason: ManageEventList
  webPassword: String
  year: String
}
type ManageSeasonList {
  count: Int
  list: [ManageSeason]
  skip: Int
  take: Int
}
type ManageSportDetails {
  createdAt: Date
  createdBy: Int
  defaultToSchedulePage: Int
  gender: String
  groupVal: String
  homeField: String
  introHtml: String
  introImageID: Int
  level1: String
  needsApproval: Int
  recordStatus: Int
  schoolId: Int
  siteSchoolSport: Int
  sportCode: String
  sportDescription: String
  sportName: String
  sportStatus: Int
  updatedAt: Date
  updatedBy: Int
}
type ManageSportDetailsList {
  count: Int
  list: [ManageSportDetails]
  skip: Int
  take: Int
}
"The object which contains all the input data for the ManageTeamStats query"
type ManageTeamStats {
  createdAt: Date
  createdBy: Int
  id: Int
  isApproved: String
  pageHtml: String
  schoolId: Int
  sport: String
  updatedAt: Date
  updatedBy: Int
}
type ManageTeamStatsList {
  count: Int
  list: [ManageTeamStats]
  skip: Int
  take: Int
}
type ManageUser {
  contracts: String
  events: String
  groups: [String]
  id: Int
  is_deleted: Boolean
  is_super_user: String
  maintenance: String
  password: String
  seasons: String
  teams: String
  user_email: String
  user_id: String
  user_level: String
}
type ManageUsersList {
  items: [ManageUser]
  limit: Int
  offset: Int
  totalFilteredItems: Int
  totalPages: Int
  totalRows: Int
}
type ModifyDeleteCount {
  count: Int
}
type Mutation {
  activateWalletCard(last4: String!): String
  activateWalletVirtualCard(id: String!): Boolean
  activateWalletVirtualCardConfirm(code: String!, id: String!): Boolean
  addParticipantGuardianDonationInviteEmails(emails: [String]): Boolean
  addParticipantGuardianDonationInviteEmailsV2(emails: [String]): [ParticipantGuardianReturn!]!
  campaignPersonListCreate(contextableId: Int!, contextableType: String!, email: String, participantUserId: Int!, personListType: String!, phone: String): CampaignPersonList
  campaignPersonListEntryDelete(personListEntryId: Int!): CampaignPersonListEntryDelete
  "Create saved search filters for campaigns for current user."
  campaignSearchFilterCreate(filterCriteria: JSON, filterName: String): CampaignSearchFilter
  "Remove saved search filters for campaigns for current user."
  campaignSearchFilterDelete(id: Int): CampaignSearchFilter
  completeWalletRegister(altName: String): Boolean
  confirmPassword(email: String!, newPassword: String, verificationCode: String!): String
  confirmWalletOrganizationInfo(altName: String): WalletConfirmOrganizationInfoResult
  "Deletes a custom template based off ID"
  contactTemplateDelete(id: Int): CustomContactTemplates
  "Saves custom contact-template for current user"
  contactTemplateSave(templateMessage: String, templateName: String, templateSubject: String): CustomContactTemplates
  createCard(card: IssueCardInput!, gateway: FINANCIAL_GATEWAY, 
    "organizationId will be replaced by raiseOrganizationId"
    organizationId: String,raiseOrganizationId: String  ): CoreCardFields! @deprecated(reason: "This will be replaced with latestCreateCard after data has been migrated from Spend and Raise")
  createFundraiserUser(firstName: String!, lastName: String!): CreatedFundraiserUser
  createOtkParticipantEntry(fundraiserId: Int!, incentiveId: Int!, size: String!): CreatedOtkEntry
  createPrefund(amount: Int!, cardType: CARD_TYPE, email: String!, fundraiserId: Int!, nameOnCard: String, shippingService: SHIPPING_SERVICE): Prefund
  createPrefundTopup(amount: Int!, fundraiserId: Int!): Boolean
  driveAddHubspotProspectPin(dealId: String, hubspotOrgId: String): String
  driveAddWinbackPin(dealId: String, hubspotOrgId: String): String
  "Finalize the (closed) fundraiser after campaign settled."
  driveCampaignFinalize(fundraiserId: Int!): IMutationResult
  "Settle the fundraiser when campaigns start to be closed campaigns."
  driveCampaignSettle(fundraiserIds: [Int!]): IMutationResult
  "Update the fundraiser. Right now only fundraiser notes can be updated."
  driveCampaignUpdate(data: DriveCampaignUpdateInput!, 
    "Fundraiser Id"
    id: Int!
  ): IMutationResult
  driveDisableActivity(dealId: String, hubspotOrgId: String): String
  driveEnableActivity(dealId: String, hubspotOrgId: String): String
  "Posts a message in the activity feed"
  driveEventActivityCreate(eventId: String!, input: DriveEventActivityInput): DriveEventActivityFeed
  "Removeds an activity feed message"
  driveEventActivityRemove(id: ID!): String
  "Updates the message and feature toggle in a activity message"
  driveEventActivityUpdate(id: ID!, input: DriveEventActivityInput!): DriveEventActivityFeed
  "Takes in 2 arguments to post the agendas"
  driveEventAgendaCreate(eventId: ID!, input: DriveEventAgendaInput!): DriveEventAgendaItem
  "Adds an attendee to event."
  driveEventAttendeeAdd(eventId: ID!, input: DriveEventAttendeeInput!, 
    "Set true to force existing attendee record update with values defined in `input`"
    update: Boolean = false
  ): DriveEventAttendee
  "Updates attendance information of attendee."
  driveEventAttendeeUpdate(eventId: ID!, input: DriveEventAttendeeInput!, userId: ID!): DriveEventAttendee
  "Removes an attendee from event."
  driveEventAttendeesRemove(eventId: ID!, userIds: [String!]!): Int
  "Create Event (Drive Event-Tracker)"
  driveEventCreate(input: DriveEventInput!): DriveEvent
  "Delete Event (Drive Event-Tracker)"
  driveEventRemove(id: ID!): String
  "Update Event (Drive Event-Tracker)"
  driveEventUpdate(id: ID!, input: DriveEventInput!): DriveEvent
  "Set tracking by specific organization current user."
  driveOrgUserTrackingSet(
    "Input fields needed to create tracking row"
    input: DriveTrackingInput,
    "Org ID of the organization. It is mapped with **'fields.id'** in **'Org'** entity"
    orgId: String!
  ): driveOrgUserTrackingReturn
  driveRemoveHubspotProspectPin(dealId: String): String
  driveRemoveWinbackPin(dealId: String): String
  "Resizes the uploaded attachment in S3 in Drive."
  driveS3ImageResize(fileUploaded: String): String
  "Generate S3 generate pre-signed url for Drive to upload. This is used for uploading big attachments to the support ticket"
  driveUploadUrlCreate(fileName: String!): String!
  eventCreate(input: CreateEventInput): Event
  eventDelete(input: DeleteEventInput): Event
  eventModify(input: ModifyEventInput): Event
  eventParticipantsDeleteMany(input: DeleteManyEventParticipantsInput): DeleteCount
  eventParticipantsUpsert(input: UpsertEventParticipantsInput): UpsertEventParticipantsCount
  eventPreparationCreate(input: CreateEventPreparationInput): DailyCalendarPreparation
  eventPreparationDelete(input: DeleteEventPreparationInput): DailyCalendarPreparation
  eventPreparationModify(input: ModifyEventPreparationInput): DailyCalendarPreparation
  eventPreparationsCreateMany(input: [EventPreparationsInput]): [EventPreparations]
  eventPreparationsDeleteMany(input: DeleteManyEventPreparationsInput): ModifyDeleteCount
  eventPreparationsModifyMany(input: ModifyManyEventPreparationsByEventInput): ModifyDeleteCount
  eventPreparationsUpsert(input: UpsertEventPreparationsInput): UpsertEventPreparationsCount
  eventTransportDetailsDeleteMany(input: DeleteManyEventTransportDetailsInput): EventTransportDetailsDeleteManyCount
  eventTransportDetailsUpsertMany(input: UpsertEventTransportDetailsInput): UpsertEventTransportDetailsCount
  facilitiesUpsert(input: [UpsertFacilitiesInput]): [FacilityLocation]
  facilityCreate(input: CreateFacilityInput): Facility
  facilityDelete(input: DeleteFacilityInput): Facility
  facilityModify(input: ModifyFacilityInput): Facility
  "Associate a User with a FinancialAccount. This will also create a User Node only if they exist in User Directory but not Orgs."
  finAcctUserAssociationCreate(finAcctId: ID!, isBeneficialOwner: Boolean = null, isContact: Boolean = null, isPrincipal: Boolean = null, isRepresentative: Boolean = null, kycId: ID = null, personId: ID = null, userId: ID!): MutationResponse
  "Add a deleted_at property to a User's FinancialAccount association. This will NOT delete the relationship."
  finAcctUserAssociationDelete(finAcctId: ID!, userId: ID!): MutationResponse
  "Update a User's FinancialAccount association properties. **Note** There is a known bug preventing status Booleans from updating from True to False."
  finAcctUserAssociationUpdate(finAcctId: ID!, isBeneficialOwner: Boolean = null, isContact: Boolean = null, isPrincipal: Boolean = null, isRepresentative: Boolean = null, kycId: ID = null, personId: ID = null, userId: ID!): MutationResponse
  "Create a processor specific FinancialAccount Node that is associated with an Org. This requires a valid Org id and a valid KYB id"
  financialAcctCreate(acctId: ID = null, applicationId: ID = null, customerId: ID = null, kybId: ID!, orgId: ID!, processor: Processor!, status: FinAcctStatus = PENDING): MutationResponse
  """
  Change a FinancialAccount status to "TERMINATED". This will NOT delete the node.
  """
  financialAcctDelete(finAcctId: ID!): MutationResponse
  "Update a FinancialAccount properties that is already associated with an Org."
  financialAcctUpdate(acctId: ID = null, applicationId: ID = null, customerId: ID = null, finAcctId: ID!, kybId: ID = null, orgId: ID!, status: FinAcctStatus = null): MutationResponse
  fundraiserStoreUrlUpdate(fundraiserId: Int!, storeUrl: String): UpdatedFundraiserStoreUrl
  "Send out email to group-leader. Support CC emails"
  groupLeaderEmailSend(
    "List of CC emails"
    ccEmails: [String!],fundraiserId: Int!, 
    "Email of group leader of campaign. This is also main recipient"
    groupLeaderEmail: String!,
    "Message in email. Plain text only."
    message: String!,
    "The subject of email"
    subject: String!
  ): IMutationResult
  helpDocumentDelete(input: HelpDocumentDeleteInput!): String
  helpDocumentUpload(input: HelpDocumentUploadInput!): String
  "Update hubspot call engagement for fundraiser"
  hubspotCallEngagementToDealAdd(fundraiserId: Int!): HubspotCallEngagement
  "Update hubspot note engagement for fundraiser"
  hubspotNoteEngagementToDealAdd(fundraiserId: Int!): HubspotCallEngagement
  insightsAddPreApprovedContacts(approver: InsAddPreApprovedContactApproverInput!, contacts: [InsPreApprovedContactInput]!, dashboardUrl: String!, org: InsAddPreApprovedContactOrgInput!): InsAddPreApprovedContactsResult!
  insightsDeletePreApprovedContact(contactId: Int!, userId: String!): InsDeletePreApprovedContactResult!
  insightsEditPreApprovedContact(contactId: Int!, orgId: String!, senderName: String!, updatedContact: InsEditPreApprovedContactInput!): InsEditPreApprovedContactResult!
  insightsEditPreApprovedContactInvite(token: String): InsEditPreApprovedInviteResult!
  insightsResendInvitePreApprovedContact(contactId: Int!, senderName: String!): InsResendPreApprovedContactResult!
  insightsUserPreferenceCreate(campaignId: Int, hidden: Boolean, orgId: String, userId: String, userPreferenceId: Int): InsightsUserPreferencesCreateResult!
  insightsUserPreferenceUpdate(campaignId: Int, hidden: Boolean, orgId: String, userId: String, userPreferenceId: Int): InsightsUserPreferencesUpdateResult!
  inviteAccept(inviteId: String): UserInviteResponse
  inviteCreate(email: String!, parent: InviteParentArguments, sendEmail: Boolean = true, user: InviteUserArguments): String!
  inviteDelete(inviteId: String): String
  issuePendingCards: [ID!]
  joinFundraiserUser(joinCode: String!, role: CampaignMemberAssociation!, userId: Int!): JoinedFundraiserID!
  joinFundraiserUserById(fundraiserId: Int!, role: CampaignMemberAssociation!, ssoId: String!, user: JoinFundraiserUserInput!): JoinedFundraiserID!
  latestVaultCardCreate(altName: String, attachCardToKybBalance: Boolean!, cardType: VaultCardType!, kybId: ID!, metadata: VaultCardMetadataInput, recipientName: String, shippingAddress: VaultAddressInput, shippingService: VaultShippingService, spendingLimitAmount: Int!, spendingLimitInterval: VaultSpendingLimitInterval!): ID!
  levelCreate(input: CreateLevelInput): Level
  levelDelete(input: DeleteLevelInput): Level
  levelModify(input: ModifyLevelInput): Level
  linkUserToSponsor(sponsorId: String!, userId: String!): Boolean
  linkUserToSponsorSchool(schoolId: String!, userId: String!): Boolean
  login(consumer: String, email: String!, password: String!): AuthChallenge
  logout: Boolean
  manageUserCreate(input: ManageUserCreateInput): ManageUser
  manageUserDelete(input: ManageUserDeleteInput): ManageUser
  manageUserUpdate(input: ManageUserUpdateInput): ManageUser
  noticeCreate(input: NoticeCreateInput): Notice
  noticeDelete(input: NoticeDeleteInput): [Notice]
  noticeModify(input: NoticeModifyInput): Notice
  notifyIncorrectWalletInfo(firstName: String!, lastName: String!, orgId: Int!): Boolean
  officialCreate(input: CreateOfficialInput): Official
  officialDelete(input: DeleteOfficialInput): Official
  officialDutiesDelete(input: DeleteOfficialDutiesInput): [OfficialDuty]
  officialDutiesUpsert(input: [UpsertOfficialDutiesInput]): [OfficialDuty]
  officialDutyCreate(input: CreateOfficialDutyInput): OfficialDuty
  officialDutyModify(input: ModifyOfficialDutyInput): OfficialDuty
  officialModify(input: ModifyOfficialInput): Official
  officialPoolCreate(input: CreateOfficialPoolByIdInput): OfficialPool
  officialPoolDelete(input: DeleteOfficialPoolInput): [OfficialPool]
  officialPoolModify(input: ModifyOfficialPoolByIdInput): OfficialPool
  officialsUpsert(input: [UpsertOfficialsInput]): [OfficialPool]
  opponentCreate(input: CreateOpponentInput): Opponent
  opponentDelete(input: DeleteOpponentInput): Opponent
  opponentModify(input: ModifyOpponentInput): Opponent
  opponentsUpsert(input: [UpsertOpponentsInput]): [Opponent]
  "Please use the 'orgs' query to fuzzy search for the Org name you need BEFORE creating one. This will create a new Org Node regardless of whether it already exists or not."
  orgCreate(city: String = null, country: String = null, description: String = null, ein_number: Int = null, fips_id: Int = null, formation_year: Int = null, hubspot_id: Int = null, mascot: String = null, name: String!, nces_category: String = null, parentOrgId: ID = null, phone: String = null, state_code: StateCode = null, state_id: String = null, street: String = null, student_count: Float = null, student_teacher_ratio: Float = null, teacher_count: Float = null, type: OrgType!, url: String = null, zip_code: Int = null): MutationResponse
  participantDonationInviteEdit(campaignID: String!, donationInviteID: String!, newEmail: String!): DonorEmailData
  participantDonationInviteEmailAdd(campaignID: String!, email: String!): DonorEmailData
  participantDonationInviteEmailFollowUp(donationInviteEmailID: Int!): DonationInviteFollowUpEmail
  participantDonationInviteSMSAdd(campaignID: String!, phoneNumber: String!): DonationInviteSMSData
  "This will update the emails of a Participant's Guardian Email field"
  participantGuardianEmailUpdate(guardianEmail: String!, secondGuardianEmail: String): ParticipantGuardianEmailUpdate!
  participantIncentiveSelectionDelete(fundraiserId: ID!, fundraiserUserIncentiveId: ID!): DeletedIncentiveRecord
  participantRewardsCreate(fundraiserId: Int!, incentiveId: Int!, size: String!, tier: Int!): CreatedParticipantRewards
  participantSignup(apps: [String], email: String!, password: String!, phoneNumber: String!): [TransportType!]!
  "Send out emails to particpants"
  participantsEmailSend(
    "The fundraiser ID"
    fundraiserId: Int!,
    "The message in email. Plain text only."
    message: String!,
    "The subject of the message"
    subject: String!
  ): IMutationResult
  "Sends out texts to particpants"
  participantsTextSend(
    "The fundraiser ID"
    fundraiserId: Int!,
    "The message to send out. Plain text only."
    message: String!
  ): IMutationResult
  paymentsApiDetachPaymentMethod(input: PaymentsApiDetachPaymentMethodInput): PaymentsApiDetachPaymentMethodResponse
  paymentsApiPayment(input: PaymentsApiPaymentIput): PaymentsApiPaymentResponse
  paymentsApiRefund(input: PaymentsApiRefundInput): PaymentsApiCreateRefundResponse
  "Schedule time (timezone-sensitive) to send out preload email to all participants"
  preloadEmailScheduleSend(
    "DateTime to send out. It support multiple format such as 2022-02-01 or 2022-02-01T00:00:00Z"
    dateTime: DateTime!,fundraiserId: Int!, 
    "Timezone of datetime to send out. e.g. American/New_York"
    timezone: String!
  ): PreloadEmailSchedule
  "Send out preload email to all participants"
  preloadEmailSend(fundraiserId: Int!): String
  preparationCreate(input: CreatePreparationInput): Preparation
  preparationDelete(input: DeletePreparationInput): Preparation
  preparationModify(input: ModifyPreparationInput): Preparation
  registerWalletUser: WalletUserRegisterResult
  roleCreate(data: RoleArguments!): Role
  roleDelete(id: String!): Role
  rolePermissionsUpdate(permissionIds: [String!]!, roleId: String!): Role
  roleUpdate(data: RoleArguments!, id: String!): Role
  samlCallback(actualEmail: String, apps: [String], consumer: String, email: String, firstName: String, lastName: String): Auth
  schoolInfoCreate(input: CreateSchoolInfoInput): SchoolInfo
  schoolInfoDelete(input: DeleteSchoolInfoInput): SchoolInfo
  schoolInfoModify(input: ModifySchoolInfoInput): SchoolInfo
  seasonCreate(input: SeasonCreateInput): Season
  seasonDelete(input: SeasonDeleteInput): [Season]
  seasonModify(input: SeasonModifyInput): Season
  seasonPostponeModify(input: SeasonPostponeUnpostponeInput): PostponeUnpostponeResponse
  seasonScheduleTeamsCreate(input: SeasonScheduleTeamsCreateInput): [Season]
  seasonUnpostponeModify(input: SeasonPostponeUnpostponeInput): PostponeUnpostponeResponse
  "Update settlement note for a fundraiser"
  settlementIssuesRecord(fundraiserId: Int!, note: String): String
  "Update settlement status for a fundraiser"
  settlementStatusUpdate(fundraiserId: Int!, settlementStatus: SettlementStatus): IMutationResult
  spendBudgetCreate(input: SpendBudgetInput!): SpendBudgetID
  spendBudgetDelete(id: String!): SpendBudgetID
  spendBudgetUpdate(id: String!, input: SpendBudgetInput!): SpendBudgetID
  spendCategoryCreate(input: SpendCategoryInput!): SpendCategoryID
  spendCategoryUpdate(id: String!, input: SpendCategoryInput!): SpendCategoryID
  spendCategoryUpsertBulk(input: [SpendUpsertCategoryInput]): [SpendCategoryID]
  spendGroupArchive(id: String!): SpendGroupID
  spendGroupBankAccessTokenCreate(id: String, publicToken: String!): SpendBankAccessCreateResponse
  spendGroupBankAccessTokenDelete(id: String): SpendBankAccessDeleteResponse
  spendGroupCheckDepositPatch(input: SpendGroupCheckDepositTagsInput!): SpendCheckDepositTagsResponse
  spendGroupCreate(input: SpendGroupInput!): SpendGroupID
  spendGroupDebitCardCreate(id: String, input: SpendDebitCardInput!): SpendDebitCardID
  spendGroupDuplicate(id: String!): SpendGroupID
  spendGroupExternalTransfer(input: SpendGroupExternalTransferInput!): SpendExternalTransferResponse
  spendGroupRosterCreate(input: SpendGroupRosterInput!): SpendGroupRosterID
  spendGroupRostersCreate(input: SpendGroupRostersInput!): [SpendGroupRosterID]
  spendGroupUpdate(id: String, input: SpendGroupInput!): SpendGroupID
  spendGuardianSignup(input: SpendGuardianSignupInput!): SpendUserID
  spendInvoiceChangeRequest(input: SpendInvoiceRequestChangeInput!): SpendInvoiceID
  spendInvoiceCreate(input: SpendInvoiceInput!): SpendInvoiceID
  spendInvoicePaymentDeauthorize(input: SpendInvoicePaymentDeauthorizeInput!): SpendDeauthorizeResponse
  spendInvoiceRefund(input: SpendInvoiceRefundInput!): SpendInvoiceRefundResponse
  spendInvoiceReminderCreate(input: SpendInvoiceReminderInput!): SpendNotificationID
  spendInvoiceUpdate(id: String!, input: SpendInvoiceInput!): SpendInvoiceID
  spendInvoiceUpdatePaymentMethod(input: SpendInvoicePaymentMethodUpdate!): SpendInvoiceIDs
  spendNotificationCreate(input: SpendNotificationInput!): SpendNotificationStatus
  spendOrganizationAccountTransfer(input: SpendAccountTransferInput!): SpendAccountID!
  spendOrganizationBankAccessTokenCreate(publicToken: String!): SpendBankAccessCreateResponse
  spendOrganizationBankAccessTokenDelete: SpendBankAccessDeleteResponse
  spendOrganizationCheckDepositPatch(input: SpendOrganizationCheckDepositTagsInput!): SpendCheckDepositTagsResponse
  spendOrganizationCreate(externalId: String!, userId: String!): SpendOrganizationID
  spendOrganizationDebitCardCreate(input: SpendDebitCardInput!): SpendDebitCardID
  spendOrganizationExternalTransfer(input: SpendOrganizationExternalTransferInput!): SpendExternalTransferResponse
  spendOrganizationSignup: SpendSignupFormResponse
  spendPaymentMethodCreate(input: SpendPaymentMethodInput!): SpendPaymentMethodResponse
  spendPaymentScheduleCreate(input: SpendPaymentScheduleInput!): SpendPaymentScheduleID
  spendPaymentScheduleUpdate(id: String!, input: SpendPaymentScheduleInput!, rosterIds: [String]): SpendPaymentScheduleID
  spendPaymentScheduleUpdateBySeason(input: SpendPaymentScheduleBySeasonInput!): [SpendPaymentScheduleID]
  spendRoleChange(roleId: String!, sessionId: String!): SpendRoleID
  spendSeasonCreate(input: SpendSeasonInput!): SpendSeasonID
  spendSeasonUpdate(id: String!, input: SpendSeasonInput!): SpendSeasonID
  spendSessionCreate: SpendSession
  spendSessionDelete: SpendSessionID
  spendSessionRefresh(sessionId: String!): SpendSessionID
  spendSettingsUpdate(input: SpendSettingsInput): SpendOrganizationID
  spendSignupAgreementCreate(input: SpendSignupAgreementInput!): SpendAgreementID
  spendTransactionAttachmentCreate(input: SpendTransactionAttachmentInput!): SpendTransactionAttachmentID
  spendTransactionAttachmentDelete(id: String!): SpendTransactionAttachmentID
  spendTransactionNoteCreate(input: SpendTranscationNoteInput!): SpendTransactionNoteID
  spendTransactionNoteUpdate(id: String!, input: SpendTranscationNoteInput!): SpendTransactionNoteID
  spendTransactionReconcile(input: SpendTransactionReconcileInput!): SpendReconcileTransactionID
  spendTransactionsCreate(input: SpendTransactionInput!): SpendTransactionsIdList
  spendUserAchPayment(input: SpendAchPaymentInput!): SpendAchPaymentResponse
  spendUserAchPaymentCancel(input: SpendAchPaymentCancelInput!): SpendAchPaymentID
  spendUserBankAccessTokenCreate(groupId: String!, publicToken: String!): SpendBankAccessCreateResponse
  spendUserBankAccessTokenDelete: SpendBankAccessDeleteResponse
  spendUserInviteArchive(id: String!): SpendInviteID
  spendUserInviteCreate(input: SpendInviteInput!): SpendInviteID
  spendUserInviteDelete(id: String!): SpendInviteID
  spendUserInviteResend(id: String): SpendInviteID
  spendUserInviteUpdate(id: String!): SpendInviteID
  spendUserLeaveGroup(groupId: String!): SpendUpdateResponse
  spendUserPaymentsCardDetach(input: SpendPaymentMethodDetach): SpendPaymentMethodDetachResponse
  spendUserRoleArchive(groupId: String, userId: String!): SpendUserID
  spendUserRoleUpdate(groupId: String, roleName: SpendRoleNameEnum!, userId: String!): SpendUserRoleID
  spendUserSignupUpdate(input: SpendUserSignupInput): SpendUserRoleID
  sponsorAssetArchiveToggle(archive: Boolean, assetId: String!): Asset
  sponsorCartAssetAdd(assetId: String!, attachment: String, sponsorId: String!): SponsorsOnAssets
  sponsorCartAssetRemove(cartId: Int!): SponsorsOnAssets
  sponsorCartCheckout(emailAddress: String!, orderId: String!, sponsorId: String!, sponsorName: String!): [Asset]
  sponsorCreate(city: String!, email: String!, industryId: String!, logo: String, name: String!, phone: String!, stateId: String!, streetAddress: String!, zipCode: String!): Sponsor
  sponsorDistrictCreate(fields: iSponsorDistrictFields): SponsorDistrict
  sponsorDistrictDelete(id: String!): SponsorDistrict
  sponsorDistrictUpdate(id: String!, name: String): SponsorDistrict
  sponsorInvitationCreate(emailData: DynamicEmailDataInput, invites: [InviteCreationInput]): [Invite]
  sponsorLogoUpdate(file: String, id: String!): Sponsor
  sponsorPackageAttachmentUpdate(attachment: String, cartId: Int!): SponsorsOnAssets
  sponsorPaymentIntentCreate(paymentMethod: String, save: Boolean!, sponsorId: String!): PaymentIntent
  sponsorPaymentMethodEnable(isEnabled: Boolean!, paymentMethodId: String!, sponsorId: String!): SponsorPaymentMethod
  sponsorPaymentMethodSave(paymentMethodId: String!, sponsorId: String!): SponsorPaymentMethod
  sponsorSchoolCreate(districtId: String, fields: iSponsorSchoolFields!, subDistrictId: String): SponsorSchool
  sponsorSchoolDelete(id: String!): SponsorSchool
  sponsorSchoolProgramCreate(districtId: String, fields: iSponsorSchoolProgramFields!, schoolId: String, subDistrictId: String): SponsorSchoolProgram
  sponsorSchoolProgramDelete(id: String!): SponsorSchoolProgram
  sponsorSchoolProgramUpdate(description: String, id: String!, name: String, schoolId: String): SponsorSchoolProgram
  sponsorSchoolUpdate(id: String!, name: String, streetAddress: String, subDistrictId: String, zipCode: String): SponsorSchool
  sponsorShipGroupUserAssociation(data: [sponsorshipGroupUserLink]): multipleCreationResponse
  sponsorShipLogoUpdate(file: String, id: String!): SponsorshipGroup
  sponsorShipTeamPhotoUpdate(file: String, id: String!): SponsorshipGroup
  sponsorSubDistrictCreate(districtId: String, fields: iSponsorDistrictFields): SponsorDistrict
  sponsorSubDistrictDelete(id: String!): SponsorSubDistrict
  sponsorSubDistrictUpdate(districtId: String, id: String!, name: String): SponsorSubDistrict
  sponsorUpdate(city: String, id: String!, name: String, phone: String, stateId: String, streetAddress: String, zipCode: String): Sponsor
  sponsorshipGroupAssetCreate(data: assetCreationInput): multipleCreationResponse
  sponsorshipGroupAssetDelete(id: String!): Asset
  sponsorshipGroupAssetDuplicate(id: String!): Asset
  sponsorshipGroupAssetUpdate(assetTypeId: String, description: String, expirationDate: String, id: String!, image: String, isSponsored: Boolean, location: String, name: String, pricing: Float, quantity: Int, sponsorshipGroupId: String, startDate: String): Asset
  sponsorshipGroupCreate(activityId: String!, city: String, description: String, email: String!, logo: String, message: String, motive: String, name: String!, schoolId: String!, socialMediaAccounts: iSocialMediaAccounts, stateId: String!, streetAddress: String, teamPhoto: String, zipCode: String!): SponsorshipGroup
  sponsorshipGroupDelete(id: String!): SponsorshipGroup
  sponsorshipGroupInviteRemind(email: String!, emailData: DynamicEmailDataInput, inviteId: String!, sponsorshipGroupId: String!): Boolean
  sponsorshipGroupOrderStatusUpdate(packageId: String!, rejectionReason: String, sponsorshipGroupId: String!, status: OrderStatus!): SponsorshipGroupOnOrder
  sponsorshipGroupUpdate(activityId: String, city: String, description: String, id: String!, message: String, motive: String, name: String, socialMediaAccounts: iSocialMediaAccounts, stateId: String, streetAddress: String, stripeAccountStatus: String, stripeConnectAccountId: String, zipCode: String): SponsorshipGroup
  sponsorshipGroupUserInvite(inviterName: String!, organizationName: String!, publicUrl: String!, receiverEmail: String!): Boolean
  storeBuildRequest(input: storeBuildRequestInput!): StoreBuildRequestUnionType
  storeEditInfo(input: StoreEditInfoInput!): StoreEditInfoUnionType
  storeManagerPointsUpdate(input: StoreManagerUpdatePoints): StoreManagerUpdatePointsUnionType
  storePaymentIntentCreate(input: StoreCreatePaymentIntent!): StorePaymantIntentUnionType
  storeTicketCreate(input: StoreTicketInput!): StoreTicketsUnionType
  storeTransactionSave(input: StoreSaveTransaction!): StoreTransactionUnionType
  storeTransferToCustomer(input: StoreTransferCustomer): StoreTransferPointsUnionType
  storeTransferToGL(input: StoreTransferGL): StoreTransferPointsUnionType
  storeTransferToParticipant(input: StoreTransferParticipant): StoreTransferPointsUnionType
  storeUpdateStatus(input: StoreStatusInput!): MagentoStoreUnionType
  "Send support-ticket email to the support team."
  supportTicketSend(
    "Uploaded attachments"
    attachments: [DriveFileInput!],
    "List of emails to be cc'd."
    ccEmails: [String!],
    "Device and browser info of the session that created the ticket."
    deviceInfo: String,
    "Fundraiser id if email is campaign related."
    fundraiserId: Int,
    "The message of the email."
    message: String,
    "The subject of the email."
    subject: String!,
    "Collection of blocks of information to be displayed in the email body."
    supportTicketInfo: [DriveFieldInput!],
    "The unique id for form template being used"
    templateId: String,
    "The recipient of the email based on the department."
    to: SUPPORT_TICKET_DEPARTMENT!
  ): IMutationResult
  teamCreate(input: TeamCreateInput): Team
  teamDelete(input: TeamDeleteInput): Team
  teamModify(input: TeamModifyInput): Team
  teamOfficialCreate(input: TeamOfficialCreateInput): TemplateOfficial
  teamOfficialDelete(input: TeamOfficialDeleteInput): TemplateOfficial
  teamOfficialModify(input: TeamOfficialModifyInput): TemplateOfficial
  teamPreparationCreate(input: TeamPreparationCreateInput): TemplatePreparation
  teamPreparationDelete(input: TeamPreparationDeleteInput): TemplatePreparation
  teamPreparationModify(input: TeamPreparationModifyInput): TemplatePreparation
  teamWorkerCreate(input: TeamWorkerCreateInput): TemplateWorker
  teamWorkerDelete(input: TeamWorkerDeleteInput): TemplateWorker
  teamWorkerModify(input: TeamWorkerModifyInput): TemplateWorker
  toggleCardActivation(cardId: String!, status: CARD_STATUS!): String!
  updateCurrentOrganizationMailingAddress(address: FinancialAddressInput!): Organization
  updateParticipantGroup(fundraiserId: Int!, personListsId: String!, userId: Int!): UpdatedParticipantGroupCount
  "This will update the size of a Participant's OTK item"
  updateParticipantOtkSize(fundraiserUserIncentiveId: Int!, size: String!): FundraiserUserIncentiveID!
  updatePrefund(id: String!, prefundAmount: Int, shippingService: SHIPPING_SERVICE): Boolean
  updateWalletCardStatus(id: String!, status: CARD_STATUS!): String
  updateWalletOrganization(altName: String, id: Int!, mailingAddress: FinancialAddressInput): Organization
  upgradeToManageUser: String
  upgradeToWalletUser(email: String): User
  userAssociate(orgId: ID!, product: Product!, roleId: ID!, userId: ID!): MutationResponse @deprecated(reason: "Please use userAssociationCreate instead")
  "Create first_seen and last_seen properties for a User and their product specific Org association."
  userAssociationAccess(orgId: ID!, product: Product!, userId: ID!): MutationResponse
  "Associate a User with an Org and a specific product. This will also create a User Node only if they exist in User Directory but not Orgs."
  userAssociationCreate(orgId: ID!, product: Product!, roleId: ID!, userId: ID!): MutationResponse
  "Add a deleted_at property to a User and their product specific Org association. This will NOT delete the relationship."
  userAssociationDelete(orgId: ID!, product: Product!, userId: ID!): MutationResponse
  userChallengeUpdate(id: String!, status: UserChallengeStatus!): UserChallenge
  userCreate(apps: [String], email: String!, firstName: String, language: String, lastName: String, occupation: UserOccupation, parentId: String, password: String!, phoneNumber: String!, profilePicture: String, snapRaiseId: Int): User
  userEmailConfirm(code: String!): String
  userFittingAdd(fitting: UserFittingPreference!): UserFitting
  userImpersonate(userId: String!): Auth
  userImpersonateLogout: Auth
  userInvite(email: String, joincode: String): String! @deprecated(reason: "use inviteCreate instead")
  userInviteAccept(inviteId: String): UserInviteResponse @deprecated(reason: "use inviteAccept instead")
  userPermissionsUpdate(negativePermissions: [UserPermissionAssignment!]!, permissions: [UserPermissionAssignment!]!, roleIds: [String!]!, userId: String!): UserPermissionsList
  userPhoneNumberConfirm(code: String!): String
  userRefreshSession(refreshToken: String): Auth
  userResetPassword(email: String, id: String, transport: TransportEnum, withLink: Boolean = false): UserResetPasswordResponseWithAvailableTransport
  userSignup(apps: [String], consumer: String, email: String!, firstName: String, inviteId: String, lastName: String, occupation: UserOccupation, password: String!, phoneNumber: String!, profilePicture: String): SignUpResponseWithAvailableTransport
  userSignupConfirm(code: String!, email: String!, skip: Boolean): Auth
  userSignupConfirmationResend(email: String!, transport: TransportEnum): [TransportType!]!
  userUnassignParent(email: String, parentId: String): String
  userUpdate(apps: [String], email: String, firstName: String, id: String, isConfirmed: Boolean, isDisabled: Boolean, language: String, lastName: String, occupation: UserOccupation, password: String, phoneNumber: String, profilePicture: String): User
  userUpdatePassword(email: String!, newPassword: String!, oldPassword: String!): User
  vaultDocumentGatewayUpload(documentBack: String, documentFront: String!, fileType: String!, gateway: VaultFinancialProvider!, stripeConnectAccountId: String, stripePersonId: String, type: VaultRequiredDocument!, unitApplicationId: String, vaultId: ID!): VaultMutationResponse
  vaultFinancialAccountCreate(stripeConnectAccountId: String!): String
  vaultKybCreate(address: VaultAddressInput!, customerFacingName: String!, description: String!, email: String, legalName: String!, phoneNumber: String!, structure: KYB_STRUCTURE!, taxId: String!, type: KYB_TYPE!, url: String!): ID!
  vaultKybUpdate(address: VaultAddressUpdateInput, customerFacingName: String, description: String, email: String, id: ID!, legalName: String, phoneNumber: String, structure: KYB_STRUCTURE, taxId: String, type: KYB_TYPE, url: String): ID!
  vaultKycCreate(address: VaultAddressInput!, director: Boolean, dob: VaultDobInput!, email: String!, executive: Boolean, firstName: String!, lastName: String!, owner: Boolean, percentOwnership: Int, phoneNumber: String!, representative: Boolean, ssn: String, title: String): ID!
  vaultKycUpdate(address: VaultAddressUpdateInput, director: Boolean, dob: VaultDobInput, email: String, executive: Boolean, firstName: String, id: ID!, lastName: String, owner: Boolean, percentOwnership: Int, phoneNumber: String, representative: Boolean, ssn: String, title: String): ID!
  vaultSetupIntentCreate: String!
  vaultStripeConnectAccountBankAccountDefaultSet(bankAccountId: String!, stripeConnectAccountId: String!): VaultMutationResponse!
  vaultStripeConnectAccountBankAccountDelete(bankAccountId: String!, stripeConnectAccountId: String!): VaultMutationResponse!
  vaultStripeConnectAccountCreate(vaultKybId: ID!): String!
  vaultStripeConnectAccountPaymentMethodAttach(paymentMethodId: String!, stripeConnectAccountId: String!): VaultMutationResponse!
  vaultStripeConnectAccountPayoutFrequencySet(payoutInterval: VaultPayoutInterval!, stripeConnectAccountId: String!): VaultMutationResponse!
  vaultStripeConnectAccountUpdate(stripeConnectAccountId: String!, vaultKybId: ID!): String!
  vaultStripePersonCreate(stripeConnectAccountId: String!, vaultKycId: ID!): String!
  vaultStripePersonDelete(stripeConnectAccountId: String!, stripePersonId: String!): String!
  vaultStripePersonUpdate(stripeConnectAccountId: String!, stripePersonId: String!, vaultKycId: ID!): String!
  vaultUnitBusinessApplicationAccountCreate(vaultBeneficiaryOwnersKycIds: [ID], vaultKybId: ID!, vaultOwnerKycId: ID!): UnitBusinessApplicationResponse!
  vaultUnitDepositAccountCreate(customerId: ID!): String!
  vehicleCreate(input: CreateVehicleInput): Vehicle
  vehicleDelete(input: DeleteVehicleInput): Vehicle
  vehicleModify(input: ModifyVehicleInput): Vehicle
  "Deprecated: use cron-jobs instead"
  weeklyEventEmailScheduleSend: IMutationResult
  workerDeleteMany(input: DeleteManyWorkerInput): WorkerDeleteManyCount
  workerPoolCreate(input: CreateWorkerPool): WorkerPool
  workerPoolDelete(input: DeleteWorkerPoolInput): [WorkerPool]
  workerPoolModify(input: ModifyWorkerPoolInput): WorkerPool
  workerUpsertMany(input: UpsertManyWorkersInput): WorkerUpsertManyCount
  workersUpsert(input: [UpsertWorkersInput]): [WorkerPool]
}
type MutationError {
  message: String!
  type: String
}
type MutationResponse {
  errors: [MutationError]
  properties: OrgsProperties
  success: Boolean!
}
type Notice {
  body: String
  created_at: Date
  id: Int!
  isUrgent: Int
  title: String
}
type Official {
  address: String
  city: String
  duty: String
  email: String
  event: Event
  event_id: Int
  first_name: String
  home_phone: String
  id: Int!
  last_name: String
  offic_id: String
  organization: String
  paid: String
  pay_code: String
  received: String
  salary: Float
  ssn: String
  state: String
  voucher_number: String
  work_phone: String
  worker_name: String
  zip: String
}
type OfficialAssignmentsReturn {
  grand_total: String
  official_names: [String]
  officials: [TransformedOfficialAssignment]
  total: [Total]
}
type OfficialDuty {
  duty: String
  id: Int
  is_deleted: Boolean
}
type OfficialPool {
  Address: String
  City: String
  First: String
  Home_Phone: String
  ID: String!
  Last: String
  SSN: String
  State: String
  Work_Phone: String
  Zip: String
  cell_phone: String
  email: String
  formattedSSN: String
  is_deleted: Boolean
  vendor_number: String
}
type OfficialSchedules {
  activity: String
  bus_count: Int
  bus_departure_location: String
  bus_early_dismissal_time: String
  bus_estimated_return_time: String
  bus_time: String
  cancellation_status: String
  comments: String
  confirmed: String
  driver_name: String
  driver_phone: String
  end_time: String
  event_date: String
  facility: String
  gender: String
  home_field: String
  id: Int
  levels: String
  official_address: String
  official_address_city: String
  official_address_state: String
  official_address_zip: String
  official_duty: String
  official_email: String
  official_first_name: String
  official_home_phone: String
  official_id: String
  official_last_name: String
  official_paid: String
  official_received: String
  official_row_id: String
  official_salary: String
  official_work_phone: String
  opponent: String
  place: String
  season_id: Int
  sports_code: String
  sports_description: String
  sports_group: String
  sports_name: String
  start_time: String
  vehicle_id: String
  vehicle_type: String
}
type OnException {
  exceptionCode: Int
  message: String
  type: String
}
type Opponent {
  Address: String
  Phone: String
  SchoolCode: String
  SchoolName: String
  State: String
  Zip: String
  ad_name: String
  city: String
  email: String
  fax: String
  is_deleted: Boolean
  nces_id: String
  non_school: Boolean
}
type OrderItem {
  itemId: Int
  orderId: Int
  parentItemId: Int
  price: Float
  productId: Int
  productName: String
  productType: String
  quantity: Int
  sku: String
}
type OrdersFilter {
  orders: [MagentoOrder]
  pagination: SDPagination
}
type OrdersSummary {
  baseSales: Float
  complete: BigInt
  processing: BigInt
  sales: Float
  scopeId: BigInt
  shipped: BigInt
}
type Org {
  createdAt: DateTime
  fields(names: [String] = []): JSONObject
  finAccts: [FinancialAcctNode]
  id: ID!
  migrated: DateTime
  name: String
  parent: Org
  parentId: String
  type: String!
  updatedAt: DateTime
}
type Organization {
  address: String
  altName: String
  city: String
  id: Int!
  inviteEmail: String
  last4Tin: String
  mailingAddress: FinancialAddress
  modId: String
  name: String!
  nces: String
  physicalAddress: FinancialAddress
  region: String
  street: String
  tin: String
  zip: String
}
type OrgsProperties {
  acctId: ID
  applicationId: ID
  createdAt: DateTime
  customerId: ID
  deletedAt: DateTime
  finAcctId: ID
  firstSeen: DateTime
  internal: Boolean
  isBeneficialOwner: Boolean
  isContact: Boolean
  isPrincipal: Boolean
  isRepresentative: Boolean
  kybId: ID
  kycId: ID
  lastSeen: DateTime
  migrated: DateTime
  orgId: ID
  parentId: ID
  personId: ID
  processor: Processor
  roleId: ID
  status: FinAcctStatus
  type: [String]
  updatedAt: DateTime
  userId: ID
}
type OrgsSearchResponse {
  hasNext: Boolean
  hasPrevious: Boolean
  orgs: [Org]
  total: Int
}
type OtkFundraiserProduct {
  "This otk item image will include the fundraiser logo."
  dynamicImage: String
  incentives: OtkProduct
}
type OtkParticipantData {
  id: ID!
  incentives: OtkProduct
  size: String
}
type OtkProduct {
  fitting: String
  id: ID!
  "This is the base image for the otk item. It will not include the fundraiser logo."
  image: String
  name: String
  productType: String
  sizes: String
}
type PaginationInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  page: Int!
  perPage: Int!
  totalItems: Int!
  totalPages: Int!
}
type Participant {
  campaignId: String
  email: String
  firstName: String
  id: ID!
  lastLogin: String
  lastName: String
  role: String
}
"See CampaignMembership for details"
type ParticipantCampaign {
  basicStatus: BasicCampaignStatus!
  campaignDates: CampaignDates
  campaignGoal: Int
  donationsRaised: ParticipantDonationsRaised
  "Getting donor email addresses adds time to your query"
  donorEmailAddresses: DonorEmailAddresses
  donorEmailData: [DonorEmailData]
  donorPersonListEntries: [DonorPersonListEntry]
  "Getting donor phone numbers adds time to your query"
  donorPhoneNumbers: [DonationInviteSMSData]
  fundraiserRewardLevelsCount: FundraiserRewardLevelsCount
  galleryItems: GalleryItems
  group: ParticipantGroup
  id: ID!
  isCoparticipant: Boolean
  isOTKEnabled: Boolean
  isRewardsEnabled: Boolean
  isTopEarner: Boolean!
  joinCode: String
  name: String!
  newStack_participantFundraiserLink: String
  otk: [OtkParticipantData]
  participantGoal: Int
  participantGuardianEmails: ParticipantGuardianEmail
  participantRewardsData: [ParticipantRewardsData]
  primaryColor: String!
  raiseUserId: Int
  raiseUserJoinedAt: String
  slug: String
  status: CampaignStatus!
  userFitting: UserFitting
}
type ParticipantCheer {
  anonymous: Boolean
  createdAt: DateTime
  donorMessage: String
  donorName: String
  firstName: String
  id: Int
  images: [String]
  lastName: String
  subtotalCents: Int
}
type ParticipantCheerWall {
  createdAt: DateTime
  donorMessage: String
  donorName: String
  images: [String]
  subtotalCents: Int
}
type ParticipantCheerwall {
  cheers: [ParticipantCheer]
  count: Int
}
type ParticipantDonationLinkResult {
  participantDonationLink: String
}
type ParticipantDonations {
  count: Int
  donations: [ParticipantCheerWall]
}
type ParticipantDonationsRaised {
  numberOfDonations: Int!
  subtotalCents: Int!
}
type ParticipantGroup {
  id: ID
  label: String
}
type ParticipantGuardianDonorEntry {
  fundraiserId: Int
  id: Int
}
type ParticipantGuardianEmail {
  guardianEmail: String
  secondaryGuardianEmail: String
}
type ParticipantGuardianEmailUpdate {
  id: Int
}
type ParticipantGuardianReturn {
  entry: [ParticipantGuardianDonorEntry!]
}
type ParticipantList {
  count: Int
  cursor: String
  list: [Participant]!
}
type ParticipantRewardsData {
  id: Int
  incentives: FundraiserRewardsProduct
  size: String
}
type ParticipantSSOID {
  userDirectoryId: String
}
type ParticipantTextTemplate {
  guardianTemplate: String
  participantTemplate: String
}
type ParticipantTopDonation {
  donorName: String
  subtotalCents: Int
}
type ParticipantsInfo {
  count: Int
  loggedInCount: Int
  withAtLeastOneDonation: Int
  withAtLeastTwentyInvites: Int
}
type Payee {
  address: PayeeAddress!
  name: String!
}
type PayeeAddress {
  apartment: String
  attention: String
  city: String!
  state: String!
  street: String!
  zip: String!
}
type PaymentIntent {
  clientSecret: String
  payment: Boolean
}
type PaymentMethod {
  billingDetails: BillingDetails
  card: CardDetails
  id: String
  isEnabled: Boolean
  paymentMethodId: String
  sponsorId: String
}
type PaymentsApiCreateRefundResponse {
  applicationFeeRefundAmount: Int
  id: String!
  reason: String
  refundApplicationFee: Int
  transactionId: String
}
type PaymentsApiCustomerPaymentMethod {
  billingAddress: PaymentsApiPMAddress
  brand: String
  expiration: PaymentsApiPMExpiration
  id: String!
  identifier: String!
  type: PaymentsApiCustomerPaymentMethodType!
  zipCode: String
}
type PaymentsApiCustomerResponse {
  customerId: String
  email: String!
  name: String
  paymentMethods: [PaymentsApiCustomerPaymentMethod]!
}
type PaymentsApiDetachPaymentMethodResponse {
  paymentMethodId: String!
  stripeEnv: StripeEnv!
}
type PaymentsApiPMAddress {
  city: String
  country: String
  line1: String
  line2: String
  postalCode: String
  state: String
}
type PaymentsApiPMExpiration {
  month: Int!
  year: Int!
}
type PaymentsApiPaymentResponse {
  amount: Int!
  id: String!
  paymentMethodId: String!
  snapAmount: Int!
  snapId: String!
  stripeEnv: StripeEnv!
}
type Permission {
  description: String
  id: String
  name: String
}
type PointActivityFilter {
  activities: [MagentoPointActivity]
  pagination: SDPagination
}
type PostponeUnpostponeResponse {
  affected_events: Int
  success: Boolean
}
type PotentialCustomersDeals {
  activity: String
  curricularType: String
  id: String
}
type Prefund {
  card: Card
  cardType: CARD_TYPE
  createdAt: String
  fundraiser: Fundraiser!
  id: ID!
  organization: Organization!
  prefundAmount: Int!
  shippingService: SHIPPING_SERVICE
  status: PREFUND_STATUS!
}
type PrefundList {
  list: [Prefund!]!
  pageInfo: PaginationInfo
}
"Information of a emails scheduled for release"
type PreloadEmailSchedule {
  "The date and time for release"
  dateTime: DateTime
  "The campaign id"
  fundraiserId: Int
  "The timezone for scheduled release"
  timezone: String
}
"Information of premade email templates"
type PremadeContactTemplate {
  "The message of the template. Plain text only"
  message: String
  "The name of the template"
  name: String
  "The subject of the template"
  subject: String
  templateMedium: ContactTemplateMedium
  "The type of template"
  templateType: ContactTemplateType
}
type Preparation {
  duty: String
  id: Int!
  is_deleted: Boolean
  qty: String
}
type PreparationReport {
  comments: String
  event: Int
  id: Int
  prep: String
  qty: String
}
type PreparationSheet {
  activity: String
  bus_count: Int
  comments: String
  confirmed: String
  driver_name: String
  driver_phone: String
  end_time: String
  event_date: String
  facility: String
  fee: Float
  g_s: String
  gender: String
  home_field: String
  id: Int
  levels: String
  place: String
  preparations: [PreparationReport]
  season_id: Int
  sports_code: String
  sports_description: String
  sports_group: String
  sports_name: String
  start_time: String
  vehicle_id: String
  vehicle_type: String
}
"Primary Group Leader The primary group leader is the main contact for a fundraiser The association is not direct with a user but made through email"
type PrimaryGroupLeader {
  "Signifies user is primary group leader. Extra query."
  currentUserIsPrimary: Boolean!
  email: String
  fullName: String
  phoneNumber: String
}
type ProductColor {
  code: Int
  id: Int
  swatch: String
  type: Int
  value: String
}
type ProductGroupAndColors {
  attributeId: Int
  childs: [ProductColor]
  enabled: Int
  groupCode: String
  groupId: Int
  type: Int
  visual: String
}
type PublicFundraiserData {
  alternateColor: String
  description: String
  endDate: DateTime
  fanStore: Boolean
  goal: Int
  id: ID!
  incStore: Boolean
  joinCode: String
  logo: String
  name: String
  participantGoal: Int
  personalMessage: String
  primaryColor: String
  programLeader: String
  programType: String
  secondaryColor: String
  startDate: DateTime
  status: String
  whyDonations: String
}
type PublicParticipantData {
  firstName: String
  image: Boolean
  lastName: String
  phoneNumber: Boolean
}
type Query {
  accountTransactions(input: AccountTransactionsInput!): [Transaction]!
  authenticationFlow(email: String): AuthenticationFlow
  busSchedules(input: CommonSchedulesFiltersInput): [busSchedules]
  "Return startDateTime and endDateTime as formatted UTC strings"
  campaignDates(campaignId: String!): CampaignDates
  campaignHistoryListGet(fundraiserId: Int): [CampaignHistoryList]
  campaignKyc(campaignId: String!): CampaignKyc
  "Query uses Users JWT to find their Memberships See CampaignMembership type for details"
  campaignMemberships: [CampaignMembership!]!
  "List of saved search filters for campaigns of current user."
  campaignSearchFiltersGet: [CampaignSearchFilter]
  "List campaigns based on logged-in user"
  campaigns(
    "Filter campaigns by account-manager. Applicable for sales manager only."
    accountManagerIds: [Int!],
    "Filter closed campaigns days closed. Valid values are '0-31' and '32+'"
    daysClosed: String,
    "Filter upcoming campaigns by the days to launch. Valid values are '0-14', '15-45', '46+'"
    daysToLaunch: String,
    "@Deprecated. Ignore logged-in context and show all"
    fetchAllCampaigns: Boolean,
    """
    Set Team-Selling context. If true, it will list campaigns that reassigned to account-manager"
    """
    getTeamSelling: Boolean,
    "number of campaigns returned per page. Default is 25"
    limit: Int,offset: Int, 
    "Filter campaigns by salesreps. Applicable for sales manager only"
    salesrepIds: [Int!],
    "Filter the campaigns by name"
    searchTerm: String,sortDirection: SortDirection, sortField: SortField, 
    "Status of campaigns. Valid values are 'closed', 'finalized', 'settled', 'active' and 'upcoming'"
    status: String
  ): CampaignList
  """
  This query is only to be used by user-directory to hide or show the "Help Fundraise" link for Parent/Guardian
  """
  childrensFundraiserSplitStatus(ids: [String!]!): JSON
  competitionList(input: GetCompetitionListInput): [TransformedEventReturn]
  consumers(hidden: Boolean = false): [Consumer]
  currentPrefunds: PrefundList
  currentWalletOrganization: Organization
  "List of contact templates based on current user"
  customContactTemplatesGet: [CustomContactTemplates]
  dailyCalendarBusSchedules(input: GetDailyCalendarBusScheduleByDateInput): TransformedDailyCalendarBusSchedule
  dailyCalendarEvents(input: GetDailyCalendarEventsByDateInput): [TransformedDailyCalendarEventReturn]
  dailyCalendarOfficials(input: GetDailyCalendarOfficialsByDateInput): TransformedDailyCalendarOfficials
  dailyCalendarPreparations(input: GetDailyCalendarPreparationsByDateInput): TransformedDailyCalendarPreparation
  dailyCalendarWorkers(input: GetDailyCalendarWorkersByDateInput): TransformedDailyCalendarWorkers
  daySchedules(input: CommonSchedulesFiltersInput): [CommonSchedules]
  donationLevelsByFundraiserId(fundraiserId: String!): [DonationLevel!]!
  donationTopEarner(fundraiserId: String!): DonationTopEarner
  "Blocking this query for now, however it can be used securely within campaign memberships This query will work for both group leaders & participants"
  donorEmailAddresses(fundraiserId: Int!, userId: Int!): DonorEmailAddresses
  donorEmailData(fundraiserId: Int!, userId: Int!): [DonorEmailData]
  donorPersonListEntries(fundraiserId: Int!, userId: Int!): [DonorPersonListEntry]
  donorPhoneNumbers(fundraiserId: Int!, userId: Int!): DonorPhoneNumbers
  donorsParticipantOTKIncentives(fundraiserId: String!, participantId: String!): DonorsParticipantOTKIncentives
  "List all activity types of campaigns. Used by Drive"
  driveActivityTypes: [String]
  "Get details of campaigns. This endpoint need to considered to combined with searchDriveCampaign endpoint"
  driveCampaignDetails(fundraiserId: Int!): DriveCampaignDetails
  "Get statistics of the set of campaigns returned by the filter. This endpoint are meant to be used with the searchDriveCampaigns endpoint. Arguments should be the same."
  driveCampaignSearchStats(activityTypes: [String!], campaignName: String, campaignStatuses: [CampaignStatus!], endDate: DateTime, fundraiserId: Int, hasIncentive: Boolean, maxTeamSize: Int, maxTotalRaisedCents: Int, minTeamSize: Int, minTotalRaisedCents: Int, organizationIds: [Int!], organizationTypes: [String!], salesrepIds: [Int!], startDate: DateTime, territories: [String!], usStates: [String!]): DriveCampaignSearchStatistics
  "Show details of a specific event"
  driveEvent(
    "Takes in the event id"
    id: ID!
  ): DriveEvent
  "List events"
  driveEvents(limit: Int = 20, offset: Int = 0, sortBy: SortDirection, sortField: String, where: DriveEventSearchInput): DriveEventResults
  driveGetListActivitiesAvailableList(hubspotId: String, limit: Int = 25, offset: Int = 0, sortField: String): driveGetListPotentialCustomersReturn
  driveGetListActivitiesNotAvailableList(hubspotId: String, limit: Int = 25, offset: Int = 0, sortField: String): driveGetListPotentialCustomersReturn
  driveGetListCurrentCustomersList(hubspotId: String, limit: Int = 25, offset: Int = 0, sortField: String): driveGetListCurrentCustomersReturn
  driveGetListHubspotProspectsList(hubspotId: String, limit: Int = 25, offset: Int = 0, sortField: String): DriveGetlistProspectsReturn
  driveGetListOrgList(limit: Int = 25, offset: Int = 0, orgName: String, sortBy: SortDirection, sortField: String): DriveOrgListResults
  "Returns Organization Summary information of single organization"
  driveGetListOrganizationSummary(
    "Hubspot org ID"
    hubspotId: String,
    "Entity ID of the organization. It is mapped with **'fields._deprecated_raise_id'** in **'Org'** entity"
    orgId: Int!
  ): DriveGetListOrganizationSummaryReturn
  driveGetListPotentialCustomersList(hubspotId: String, limit: Int = 20, offset: Int = 0, sortField: String): driveGetListPotentialCustomersReturn @deprecated(reason: "changed name to driveGetListActivitiesAvailableList")
  driveGetListWinbackList(hubspotId: String, limit: Int = 25, offset: Int = 0, sortField: String): DriveGetlistWinbackReturn
  "Return all tracking of current user to specific organization in Drive's Get List app."
  driveOrgUserTrackings(
    "Org ID of the organization. It is mapped with **'fields.id'** in **'Org'** entity"
    orgId: String!,where: DriveOrgUserTrackingSearchInput  ): [driveOrgUserTrackingReturn]
  "List organization types used by Drive"
  driveOrganizationTypes: [String]
  "List all salesreps"
  driveSalesreps: [DriveAmSalesReps]
  "List all salesreps which had re-assigned any campaigns to current user. This endpoint is applicable for account-manager only."
  driveSalesrepsByAccountManager: [DriveAmSalesReps]
  "List all salesreps which managed by current user. This endpoint is applicable for sales manager only."
  driveSalesrepsByManager(type: SalesrepType): [DriveAmSalesReps]
  "Search Raise users by UserDirectory 's id"
  driveUsers(limit: Int = 20, offset: Int = 0, where: DriveUserSearchInput): DriveUsersResult @deprecated(reason: "Use UserDirectory 's users query instead ")
  "List Event-Tracker's venues"
  driveVenues(where: DriveVenueSearchInput): [DriveVenue]
  event(input: GetEventByIdInput): Event!
  eventCalendar(input: EventCalendarFiltersInput): [CommonCalendar]
  eventContractItems(input: eventContractItemInput): [ContractItem]
  eventOfficial(input: GetOfficialByIdInput): Official!
  eventOfficials: [Official]
  eventParticipants(input: GetEventParticipantsByIdInput): EventParticipants!
  eventPreparations(input: GetEventPreparationsByIdInput): EventPreparations!
  eventPreparationsByEvent(input: GetEventPreparationsByEventIdInput): [EventPreparations]
  eventTransportDetailsByEventOrDates(input: GetEventTransportDetailsByEventOrDatesInput): [EventTransportDetails]
  eventWorker(input: GetWorkerByIdInput): Worker!
  eventWorkers: [Worker]
  eventWorkersByEvent(input: GetWorkersByEventIdInput): [Worker]
  events: [Event]
  eventsParticipants: [EventParticipants]
  eventsPreparations: [EventPreparations]
  eventsTransportDetails: [EventTransportDetails]
  facilities: [Facility]
  facility(input: GetFacilityByPlaceNameInput): Facility!
  facilityCalendar(input: CommonCalendarFiltersInput): [CommonCalendar]
  facilityGrid(input: CommonGridFiltersInput): [CommonGrid]
  facilitySchedules(input: CommonSchedulesFiltersInput): [CommonSchedules]
  family: Family
  feeReportSheets(input: CommonSheetFiltersInput): [CommonSheet]
  "Get all Financial Accounts that are associated with a Stripe Connect Account id"
  financialAcctAcctId(acctId: ID!): [FinancialAcctNode!]!
  "Get all Financial Accounts that are associated with an Org. If you are looking for Financial Accounts associated with a parent Org, please use the 'financialAcctRoot' query."
  financialAcctOrg(orgId: ID!): [FinancialAcctNode!]!
  "Get all Financial Accounts that are associated with a parent Org. This includes parents of parents and all the way up the tree. This will NOT return the Financial Accounts for the target Org, please use the 'financialAcctOrg' query for specific Orgs."
  financialAcctRoot(orgId: ID!): [FinancialAcctNode!]!
  "Get all User data associated with a single Financial Account."
  financialAcctUsers(finAcctId: ID!): [FinancialAcctUser!]!
  fundraiser(fundraiserId: String!): Fundraiser
  fundraiserCheerwall(fundraiserId: String!, take: Int!): FundraiserCheerwall
  fundraiserDonations(fundraiserId: String!, take: Int!): FundraiserDonations
  "resourceId is the fundraiserId"
  fundraiserEntityResources(resourceId: Int!): FundraiserEntityResource
  fundraiserGroups(joinCode: String!): [FundraiserGroup]
  fundraiserRaisedAmount(fundraiserId: String!): FundraiserRaisedAmount
  fundraiserRewardLevelsCount(fundraiserId: String!): FundraiserRewardLevelsCount
  fundraiserRewardsDetails(fundraiserId: String!): [FundraiserRewardsProduct]
  fundraiserTopDonation(fundraiserId: String!): FundraiserTopDonation
  fundraiserUserRole(fundraiserId: Int!): FundraiserUserRole
  galleryItems(fundraiserId: String!): GalleryItems
  getCampaignRoster(campaignId: String!): [Roster]
  getFundraiserUserID: Int
  getInsightsUserOrgs(userId: Int!): [InsOrg]!
  getParticipantDonationLinkData(fundraiserId: Int!, userId: Int!): ParticipantDonationLinkResult
  getSalesRepHome(zip: String!): HmSalesRep!
  getUserSavedSalesRep(udId: String!): UserSavedRep!
  "List of group leaders"
  groupLeaders(cursor: String, groupLeaderId: Int, limit: Int): GroupLeaderList
  helpDocumentsList: [String]
  infoSheets(input: CommonSheetFiltersInput): [CommonSheet]
  insightsCampaignDonations(campaignIds: [Int]!): [InsCampaignDonation]!
  insightsCampaignRaiseEntityInfo(campaignId: Int!): InsCampaignRaiseEntityInfo!
  insightsCampaignSettlements(campaignIds: [Int]!): [InsCampaignSettlement]!
  insightsCampaignsData(campaignIds: [Int]!): InsCampaignsData!
  insightsDonorParticipantContacts(campaignIds: [Int]!): [InsDonorParticipantContact]!
  insightsOrgsCampaignsSummary(orgCampaignIds: [InsOrgCampaignSummaryInput]!): [InsOrgCampaignSummary]!
  insightsPreApprovalTokenValidation(token: String): [InsPreApprovedContact]!
  insightsPreApprovedContacts(orgIds: [Int]): [InsPreApprovedContact]!
  insightsPreApprovedContactsEmailTest(emails: [String]!, orgId: String!): [InsEmailTestPreApprovedContactResult]!
  insightsSalesRepInfo(salesRepEmail: String!): InsSalesRepInfo
  insightsUserPreferences(campaignId: Int!, userId: String!): InsightsUserPreference
  invite(id: String): InviteInfo
  invites(limit: Int! = 25, offset: Int = 0, showAll: Boolean): [InviteList]
  level(input: GetLevelByIdInput): Level!
  levelGrid(input: CommonGridFiltersInput): [CommonGrid]
  levels: [Level]
  "Retrieves a specific coach by its ID."
  manageCoach(id: Int!): ManageCoach
  "Retrieves a list of coaches based on the provided filter."
  manageCoachList(filter: ManageCoachListFilter): ManageCoachList
  "Retrieves a specific event by its ID."
  manageEvent(id: Int!): ManageEvent
  "Retrieves a list of events based on the provided filter."
  manageEventList(filter: ManageEventListFilter): ManageEventList
  "Get a manage organization by web folder"
  manageOrganization: ManageOrganization
  "Get a list of all manage organizations"
  manageOrganizationList(filter: ManageOrganizationFilter): ManageOrganizationList
  managePlayerList(filter: ManagePlayerListFilter): ManagePlayerList
  manageProgram(id: Int!): ManageProgram
  manageProgramList(filter: ManageProgramListFilter): ManageProgramList
  manageSeason(seasonId: Int!): ManageSeason
  manageSeasonList(filter: ManageSeasonListFilter!): ManageSeasonList
  manageSportDetail(id: Int!): ManageSportDetails
  manageSportDetailsList(filter: ManageSportDetailsListFilter): ManageSportDetailsList
  manageUser(input: ManageUserInput): ManageUser
  manageUsersList(input: ManageUsersListOptions): ManageUsersList
  me: UserWithPermissions
  notices: [Notice]
  officialAssignments(input: GetOfficialAssignmentsInput): OfficialAssignmentsReturn
  officialDuties: [OfficialDuty]
  officialDuty(input: GetOfficialDutyByIdInput): OfficialDuty
  officialListsReport(input: EventOfficialReportFilter): [EventOfficialReport]
  officialPoolById(input: GetOfficialPoolByIdInput): OfficialPool!
  officialPools: [OfficialPool]
  officialSchedules(input: CommonSchedulesFiltersInput): [OfficialSchedules]
  opponent(input: GetOpponentBySchoolCodeInput): Opponent!
  opponentEventsApplyFilters(input: GetEventsFilteredByOpponentStartAndEndDate): [EventsOpponent]
  opponentSchedules(input: CommonSchedulesFiltersInput): [CommonSchedules]
  opponents: [Opponent]
  """
  Get Org Node properties by its Org id. If hierarchy is set to true, it will return all the children of the organization, but NOT the target Org. 'fields' returns JSON of all remaining properties. You can optionally limit this to specific fields by passing in an array of keys. Example: "names": [ "country", "zip_code" ]
  """
  org(hierarchy: Boolean = false, id: ID!): [Org]
  "Get an Org id by its Raise id. This ONLY returns an Org id, not the full Org Node."
  orgId(raiseId: Int!): String
  "Get all Users that are associated with an Org and a specific product. This includes role and a boolean if the user is internal (snap-raise or snapraise email)."
  orgUserAssociations(orgId: ID!, product: Product!): [UserNode]
  "Fuzzy search for Orgs by their name property."
  orgs(nameIncludes: String!): [Org]
  "If you are simply searching by name property, please use the 'orgs' query. This advanced search searches by type or specific properties. Default limit is 25 items."
  orgsSearch(pagination: OrgsSearchPaginationInput, where: OrgsSearchWhereInput): OrgsSearchResponse
  "This query will return OTK Fundraiser Product details"
  otkFundraiserData(fundraiserId: ID!): [OtkFundraiserProduct]
  "This query will return OTK Participant details"
  otkParticipantDetails(fundraiserId: ID!): [OtkParticipantData]
  "This query will return the most recent OTK Participant details"
  otkPastParticipantDetails(fundraiserId: ID!): [OtkParticipantData]
  participantCheerwall(fundraiserId: String!, participantId: String!, take: Int!): ParticipantCheerwall
  participantDonations(fundraiserId: String!, participantId: String!, take: Int!): ParticipantDonations
  participantDonationsRaised(fundraiserId: Int!, userId: Int!): ParticipantDonationsRaised!
  "This query will return the incentives a Participant earned for a given fundraiser"
  participantEarnedRewardsDetails(fundraiserId: String!, userId: Int!): [ParticipantRewardsData]
  participantGroup(campaignId: String!, userId: Int!): ParticipantGroup
  participantGuardianEmailQuery(userId: Int!): ParticipantGuardianEmail
  "This query will return Participant Rewards details"
  participantRewardsDetails(fundraiserId: String!, userId: Int!): [ParticipantRewardsData]
  participantSSOId(fundraiserId: Int!, userId: Int!): ParticipantSSOID
  participantTextTemplate(fundraiserId: Int!, userId: Int!): ParticipantTextTemplate
  participantTopDonation(fundraiserId: String!, participantId: String!): ParticipantTopDonation
  "List of participants"
  participants(cursor: String, limit: Int, 
    "fundraiser_user Id"
    participantId: Int
  ): ParticipantList
  paymentsApiCustomer(input: PaymentsApiCustomerInput!): PaymentsApiCustomerResponse!
  payouts(campaignId: Int!): [Payout]!
  permissions: [Permission]
  prefund(fundraiserId: Int, id: String): Prefund
  prefunds(fundraiser: FundraiserSearchParams, limit: Int = -1, name: String, offset: Int = 0, organization: OrganizationSearchParams, status: [FUNDRAISER_STATUS]): PrefundList
  "List of pre-made contact templates"
  premadeContactTemplatesGet: [PremadeContactTemplate]
  preparation(input: GetPreparationByIdInput): Preparation!
  preparationReportSheets(input: CommonSheetFiltersInput): [PreparationSheet]
  preparations: [Preparation]
  "This resolver is only for testing purposes at this time"
  primaryGroupLeader(campaignId: String!): PrimaryGroupLeader
  "Identifier uses fundraiser join_code or slug"
  publicFundraiserData(fundraiserId: Int, identifier: String): PublicFundraiserData
  publicParticipantData(userId: Int!): PublicParticipantData
  role(id: String!): Role
  roles(id: String): [Role]
  schoolInfo(input: GetSchoolInfoByIdInput): SchoolInfo!
  schoolInfos: [SchoolInfo]
  "Search campaigns"
  searchDriveCampaigns(
    "Search by activity types. e.g. 'baseball', 'music', 'football', etc."
    activityTypes: [String!],campaignName: String, 
    "Status of campaign"
    campaignStatuses: [CampaignStatus!],
    "Search campaigns that has end date equal to"
    endDate: DateTime,fundraiserId: Int, 
    "Search campaigns that has incentive only"
    hasIncentive: Boolean,
    "Search campaigns that settlement is pending. Use by internal tools"
    isPendingSettlement: Boolean,limit: Int = 25, 
    "Search campaigns that has total member in group less or equal than this value"
    maxTeamSize: Int,
    "Search campaigns that has current total donation amount smaller than this value"
    maxTotalRaisedCents: Int,
    "Search campaigns that has total member in group larger or equal than this value"
    minTeamSize: Int,
    "Search campaigns that has current total donation amount larger than this value"
    minTotalRaisedCents: Int,offset: Int = 0, 
    "Search by Organization"
    organizationIds: [Int!],
    "Search by organization type. e.g. 'Organization', 'School', 'District', 'Club', etc."
    organizationTypes: [String!],
    "Search campaigns by salesrep"
    salesrepIds: [Int!],sortDirection: SortDirection, sortField: SortField, 
    "Search campaigns that has start date equal to"
    startDate: DateTime,
    "Not in used"
    territories: [String!],
    "Search by short-code US states. e.g. 'TX', 'CA', etc."
    usStates: [String!]
  ): DriveCampaignList
  "Search Raise's Organization. @Deprecated: should be replaced by Orgs API"
  searchDriveOrganizationsByName(limit: Int, offset: Int, organizationName: String): DriveOrganizationList
  season(input: SeasonByIdInput): Season!
  seasonByYearAndTeam(input: SeasonByYearTeamInput): [Season]
  seasonEventWizard(input: SeasonEventWizardInput): [Event]
  seasons: [Season]
  shipments(externalId: ShipmentInput): ShipmentResponse!
  spendAccountExport(status: String!): ExportFile
  spendBudget(id: String!): SpendBudgetResponse
  spendBudgetExport: ExportFile
  spendBudgets(groupId: String): SpendBudgetsResponse
  spendBudgetsProgramSummary: SpendBudgetSummaryResponse
  spendBudgetsSummary(groupId: String): SpendBudgetSummaryResponse
  spendCategories(filterBy: CategoryFilterEnum, filterValue: String, groupId: String): SpendCategoryResponse
  spendDataForHome(udid: String!): HmSpendData!
  spendGroup: SpendGroup
  spendGroupBankAccounts(groupId: String): SpendBankAccountsResponse
  spendGroupBankLinkTokenCreate(id: String): SpendBankLinkCreateResponse
  spendGroupById(id: String!): SpendGroup
  spendGroupDebitCards(id: String): SpendDebitCardResponse
  spendGroupRosterById(id: String!): SpendRoster
  spendGroupRosters(filterBy: GroupRosterFilterEnum, filterValue: String): SpendGroupRosterResponse
  spendGroups: SpendGroupResponse
  "List groups with pagination/filtering and sorting. Valid sort.field: name, seasonStartDate, seasonEndDate, playerCount, paid, upcoming, pastDue, dueToday, processing, paymentScheduleStatus"
  spendGroupsFiltered(pagination: SpendPaginationInput, sort: SpendSortInput, where: SpendGroupsWhereInput): SpendGroupsResponse
  spendGroupsOverviewDashboard: GroupsOverviewDashboardResponse
  spendGuardianHighlight: SpendGuardianHighlight
  spendInvite(id: String!): SpendInviteResponse
  spendInvites(filterBy: InviteFilterEnum, filterValue: String): SpendInviteResponse
  spendInvitesFiltered(pagination: SpendPaginationInput, sort: SpendSortInput, where: SpendInviteWhereInput): SpendInviteResponse
  spendInvoiceById(id: String!): SpendInvoice
  spendInvoices(filterBy: InvoiceFilterEnum, filterValue: String, limit: Int): SpendInvoiceResponse
  spendInvoicesExport(filters: [SpendInvoiceFilter], limit: Int): ExportFile
  spendInvoicesFiltered(filters: [SpendInvoiceFilter], limit: Int): SpendInvoiceResponse
  spendInvoicesMock(filterBy: InvoiceFilterEnum, filterValue: String, limit: Int): SpendMockInvoiceResponse
  spendOrganization: SpendOrganization
  spendOrganizationAccounts: SpendAccountResponse
  spendOrganizationBankAccounts: SpendBankAccountsResponse
  spendOrganizationBankLinkTokenCreate: SpendBankLinkCreateResponse
  spendOrganizationById(id: String!): SpendOrganization
  spendOrganizationDebitCards: SpendDebitCardResponse
  spendOrganizations(pagination: SpendPaginationInput, where: SpendOrganizationsWhereInput): SpendOrganizationsResponse
  spendPaginatedInvoices(filters: [SpendInvoiceFilter], pagination: SpendPaginationInput, sort: SpendSortInput): SpendInvoiceResponse
  spendPaymentScheduleById(id: String!): SpendPaymentSchedule
  spendPaymentSchedules(groupIdOrSeasonId: String): [SpendPaymentSchedule]
  spendPolicy: SpendPolicy
  spendRoleCurrent(sessionId: String!): SpendRole
  spendRoles: SpendRoleResponse
  spendRosters(filterBy: RosterFilterEnum, filterValue: String): SpendRosterResponse
  spendRostersFiltered(pagination: SpendPaginationInput, sort: SpendSortInput, where: SpendGroupRostersWhereInput): SpendRosterResponse
  spendSettings: SpendSettings
  spendTransaction(id: String): SpendBankTransactionResponse
  spendTransactionAttachment(id: String!): TransactionAttachmentsResponse
  spendTransactionAttachmentsByPaymentId(id: String!): TransactionAttachmentsResponse
  spendTransactionNotes(id: String): TransactionNotesResponse
  spendTransactionNotesByPaymentId(id: String): TransactionNotesResponse
  spendTransactions(filterBy: TransactionFilterEnum, filterValue: String, groupId: String, limit: Int): SpendBankTransactionsResponse @deprecated(reason: "Use spendTransactionsFiltered")
  spendTransactionsExport(filters: [SpendTransactionFilter], limit: Int): ExportFile
  spendTransactionsFiltered(filters: [SpendTransactionFilter], limit: Int): SpendBankTransactionsResponse
  spendUserAccountBearerToken(input: SpendAccountBearerToken): SpendAccountBearerTokenResponse
  spendUserBankAccounts: SpendBankAccountsResponse
  spendUserBankLinkTokenCreate: SpendBankLinkCreateResponse
  spendUserVerificationToken: SpendVerificationTokenResponse
  sponsor(id: String!): Sponsor
  sponsorAssets(orderBy: orderByClauseGroups, skip: Int = 0, take: Int = 5, where: whereClauseAssets): Assets
  sponsorCartAsset(assetId: String!, sponsorId: String!): SponsorsOnAssets
  sponsorCartAssets(sponsorId: String!): [Asset]
  sponsorCountForAssets(schoolId: String!): AssetsCount
  sponsorDataForHome(orgId: String!): HmSponsorData!
  sponsorDistrict(id: String!): SponsorDistrict!
  sponsorDistricts(skip: Int = 0, take: Int = 5): SponsorDistricts
  sponsorEnabledPaymentMethod(sponsorId: String!): PaymentMethod
  sponsorIndustries: [Industry]
  sponsorInvitationCheckByMailId(email: String!, sponsorshipGroupId: String!): Boolean
  sponsorPackageDetails(packageId: String!): SponsoredSponsorShipGroup
  sponsorPaymentMethods(sponsorId: String!): [PaymentMethod]
  sponsorSchool(from: String, id: String): SponsorSchool!
  sponsorSchoolProgram(id: String!): SponsorSchoolProgram!
  sponsorSchoolPrograms(from: String, skip: Int = 0, take: Int = 5): SponsorSchoolPrograms
  sponsorSchoolUsers(schoolId: String!): [Link]
  sponsorSchools(from: String, skip: Int = 0, take: Int = 5): SponsorSchools
  sponsorState(id: String!): SponsorState
  sponsorStates: [SponsorState]
  sponsorSubDistrict(id: String!): SponsorSubDistrict!
  sponsorSubDistricts(from: String, skip: Int = 0, take: Int = 5): SponsorSubDistricts
  sponsorUsers(sponsorId: String!): [Links]
  sponsoredSponsorshipGroups(name: String!, orderBy: orderByClauseGroups, skip: Int = 0, sponsorId: String!, take: Int = 5): SponsoredSponsorShipGroups
  sponsors(skip: Int = 0, sponsorshipGroupId: String!, take: Int = 5, where: whereClauseSponsors): Sponsors
  sponsorshipGroup(id: String!): SponsorshipGroup!
  sponsorshipGroupAccountLink(sponsorshipGroupId: String!): AccountLink
  sponsorshipGroupActivities: [Activity]
  sponsorshipGroupActivity(id: String!): Activity
  sponsorshipGroupAsset(id: String!): Asset!
  sponsorshipGroupAssetTypeValues(assetTypeId: String!): [AssetTypeValue]
  sponsorshipGroupAssetTypes(where: whereClauseAssetTypes): [AssetType]
  sponsorshipGroupAssets(orderBy: orderByClauseGroups, skip: Int = 0, take: Int = 5, where: whereClauseAssets): Assets
  sponsorshipGroupInvites(orderBy: orderByClauseInvites, skip: Int = 0, take: Int = 5, where: whereClauseInvites): Invites
  sponsorshipGroupOrders(skip: Int = 0, take: Int = 5, where: whereClauseSponsorshipGroupOrders): SponsorshipGroupOnOrders
  sponsorshipGroupOrdersCSV(sponsorshipGroupId: String!): String
  sponsorshipGroupOrdersStats(sponsorshipGroupId: String!): SponsorshipGroupOrdersStats
  sponsorshipGroupPricingForCurrentYear(schoolId: String!): sumResponse
  sponsorshipGroupPrimaryContact(sponsorshipGroupId: String): sponsorshipGroupUser
  sponsorshipGroups(orderBy: orderByClauseGroups, skip: Int = 0, take: Int = 5, where: whereClauseSponsorShipGroups): SponsorshipGroups
  sponsorshipHistory(sponsorId: String!, sponsorshipGroupId: String!): [packages]
  sponsorshipOrders(name: String!, orderBy: orderByPackages, skip: Int = 0, sponsorId: String!, take: Int = 5, where: whereClausePackages): sponsoredOrders
  sponsorshipPackages(name: String!, orderBy: orderByPackages, skip: Int = 0, sponsorId: String!, take: Int = 5, where: whereClausePackages): mySponsorships
  storeAllBrands: StoreBrandsUnionType
  storeAllProductsGroupsAndColors: StoreProductGroupsAndColorsUnionType
  storeBestSeller(scopeId: Int!): StoreBaseSellerUnionType
  storeByScopeId(scopeId: Int!): MagentoStoreUnionType
  storeDataForHome(fundraiserId: [Int!], uEmail: String!): HmStore!
  storeEarnedPointsGraph(input: StorePointEarnedGraphInput): MagentoStorePointsEarnedUnionType
  storeGLCampaigns(input: StoreUserCampaignsInput): StoreUserCampaignUnionType
  storeGLParticipants(input: StoreUserParticipantsInput): StoreUserParticipantUnionType
  storeOrderFilter(input: OrderFilterInput): OrdersFilterUnionType
  storeOrderItemImages(itemIds: [Int!]!): StoreOrderItemsUnionType
  storeOrderSalesGraph(input: OrderGraphInput): storeOrderSalesGraphUnionType
  storeOrderSummary(scopeId: Int!): OrdersSummaryUnionType
  storeOrdersCsv(scopeId: Int!): MagentoOrderUnionType
  storePointActivityFilter(input: PointsActivityFilterInput): PointActivityFilterUnionType
  storePointsActivityCsv(scopeId: Int!): MagentoPointActivityUnionType
  storeSubscribedUser: StoreSubscribedUserUnionType
  storeTickets(scopeId: Int!): StoreTicketUnionType
  storeUserDetails(email: String!): StoreUserInfoUnionType
  storesByCampaignIds(input: StoreByCampaignIdsInput): StoreFilterUnionType
  storesByGLEmail(input: StoreByGLEmailInput): StoreFilterUnionType
  storesSummaryByCampaignIds(input: StoreSummaryByCampaignIdsInput): StoresSummaryUnionType
  storesSummaryByGLEmail(input: StoresSummaryByGLEmailInput): StoresSummaryUnionType
  team(input: TeamByCodeInput): Team!
  teamOfficials(input: OfficialByIdInput): [TemplateOfficial]
  teamOrgSchedules(input: CommonSchedulesFiltersInput): [CommonSchedules]
  teamPreparations(input: PreparationByIdInput): [TemplatePreparation]
  teamWorkers(input: WorkerByIdInput): [TemplateWorker]
  teams: [Team]
  transactionDetail(transactionId: UUID!): TransactionDetail
  transactions(input: TransactionsInput!): [Transaction]!
  ""
  twispCardBalances(index: twispCardBalances_indexes, limit: Int32 = "1000", scope: String, sort: Sort, where: Where): [twispCardBalances]
  ""
  twispCards(index: twispCards_indexes, limit: Int32 = "1000", scope: String, sort: Sort, where: Where): [twispCards]
  ""
  twispStripeHooks(index: twispStripeHooks_indexes, limit: Int32 = "1000", scope: String, sort: Sort, where: Where): [twispStripeHooks]
  ""
  twispTransactions(index: twispTransactions_indexes, limit: Int32 = "1000", scope: String, sort: Sort, where: Where): [twispTransactions]
  unconfirmedEvents(input: UnconfirmedEventsFiltersInput): UnconfirmedEventsList
  updateSavedSalesRep(snapRepEmail: String!, udId: String!): UserSavedRep!
  user(email: String, id: String): User
  "Get all Orgs that are associated with a User and a specific product."
  userAssociations(id: ID!, product: Product!): [Org]
  userFitting: UserFitting
  userPermissions(userId: String): UserPermissionsList
  userPublic(id: String): UserPublic
  userSponsor(userId: String!): Link
  userSponsorGet(userId: String!): Links
  userSponsorSchool(userId: String!): Link
  users(isInternal: Boolean = false, limit: Int! = 25, offset: Int, searchTerm: String, snapRaiseId: Int, snapSpendId: Int): Users
  vaultAccountStatus(accountId: ID, accountRepresentativeGatewayId: String, applicationId: ID, beneficialOwnersGatewayIds: [String!], provider: VaultFinancialProvider!): VaultAccountStatus!
  vaultCard(id: String!): Card!
  vaultKyb(id: ID!): VaultKyb!
  vaultKyc(id: ID!): VaultKyc!
  vaultStripeConnectAccountBankAccountListFetch(stripeConnectAccountId: String!): [VaultBankAccount]
  vaultStripeConnectAccountFetch(stripeConnectAccountId: ID!): JSONObject
  vaultVgsValue(value: String!): String!
  vehicle(input: GetVehicleByIdInput): Vehicle!
  vehicles: [Vehicle]
  workerPoolById(input: GetWorkerPoolByIdInput): WorkerPool!
  workerPools: [WorkerPool]
}
type RaiseUser {
  email: String
  "SSO User ID"
  id: String
}
type Role {
  description: String
  id: String
  name: String
  permissions: [RolePermission]
  scope: String
  title: String
}
type RolePermission {
  id: String
  permission: Permission
  permissionId: String
  roleId: String
}
type Roster {
  id: ID
  members: [RosterMember]
  name: String
}
type RosterMember {
  association: CampaignMemberAssociation
  id: ID
  userId: String
  wasDeleted: Boolean
}
type SDPagination {
  limit: Int
  offset: Int
  total: BigInt
}
"Information of a emails scheduled for cron jobs"
type ScheduledReleaseInfo {
  "The date and time for release"
  date: DateTime
  "The timezone for scheduled release"
  timezone: String
}
type SchoolInfo {
  Schoolname: String
  ad: String
  ad_contract_signee: String
  address: String
  ccemail: String
  city: String
  conf_text_type: String
  email: String
  email_reminder: String
  email_reminder_officials: String
  email_reminder_workers: String
  enable_cc_email_as_origin: String
  enable_ml_updates: String
  fax: String
  icon: String
  id: String!
  mascot: String
  message_board_read_at: Date
  ml_key: String
  phone: String
  principal: String
  school_timezone: String
  secondary_ad_email: String
  secondary_ad_name: String
  signed_contract_notification: String
  ssn_on_file: String
  state: String
  state_org: String
  state_org_abbreviation: String
  use_security: String
  web_password: String
  zip: String
}
type ScopeProductColor {
  label: String
  value: Int
}
type Season {
  budget: Float
  created_at: Date
  default_time_for_event: String
  default_time_for_practice: String
  home_field: String
  is_deleted: Boolean
  preview: String
  season: String
  season_id: Int!
  sport: Team
  sport_code: String
  web_password: String
  year: String
}
"Settlement details for closed campaign."
type SettlementDetails {
  "The amount in cents that campaigns was advanced in Wallet."
  advanceAmount: Int
  "Address to send out check to"
  checkingAddress: String
  "The type of snap fee being collected. e.g. 'standard', '1+1', '20%/15%', etc."
  feeType: String
  "Total cost of incentives in cents"
  gearCost: Int
  "Code to build logo"
  incLogo: String
  "Primary color to build logo"
  incLogoPrimaryColor: String
  "Script to build logo"
  incLogoScript: String
  "Secondary color to build logo"
  incLogoSecondaryColor: String
  "Filename of Logo of Group of Campaign"
  logoImage: String
  "The amount in cents that campaigns was manual-advanced in Raise."
  manualAdvanceAmount: Int
  "Net raised amount in cents. Equals totalRaised minus snapFee and adds the otkBonus. It is the amount client received in their check/deposit."
  netRaisedTotal: Int
  "Notes of campaign"
  notes: String
  "Legal Name of Organization"
  organizationLegalName: String
  "TIN of Organization"
  organizationTin: String
  "Total bonus amount that team will receive through otk purchase cost (usually 10%) in cents."
  otkBonus: Int
  "Link to OTK Logo"
  otkLogoUrl: String
  "Percentage of participation of campaign"
  participationPercent: Int
  "Notes for settlement for this campaign"
  settlementNotes: String
  "Default Shipping address to send out gears/merchandise/check"
  shippingAddress: String
  "Total Fee in cents that Raise collects from campaigns"
  snapFee: Int
}
"Attributes for settlement status"
type SettlementStatusUpdate {
  fundraiserId: Int
  settlementStatus: SettlementStatus
}
type Shipment {
  carrier: ShipmentCarrier
  customer: String!
  destination: String
  externalId: ShipmentExternalId!
  netsuiteId: String!
  netsuiteSoTranId: String
  netsuiteTranId: String
  shippedDate: Timestamp
  source: ShipmentSource
  status: ShipmentStatus
  trackingNumbers: [String]!
  updated: Timestamp!
  workflowStage: String!
}
type ShipmentCampaignId {
  campaignId: Int!
}
type ShipmentOtherId {
  externalId: UUID!
}
type ShipmentResponse {
  shipments: [Shipment]!
  status: ResponseStatus!
}
type SignUpResponseWithAvailableTransport {
  availableTransport: [TransportEnum!]!
  result: [TransportType!]!
}
type SignupAgreement {
  content: String
  createdAt: String
  name: String
}
type SocialMediaAccounts {
  facebook: String
  instagram: String
  twitch: String
  twitter: String
}
type SpendAccount {
  account: String
  available: Int
  balance: Int
  groupStatus: String
  id: String
  name: String
  routing: String
  status: String
  type: String
}
type SpendAccountBearerTokenResponse {
  expiresIn: Int
  token: String
}
type SpendAccountID {
  id: String!
  reason: String
  status: String!
}
type SpendAccountResponse {
  accounts: [SpendAccount]
  count: Int
  groupsBalance: SpendGroupAccountBalances
  totalBalance: Int
}
type SpendAchPaymentID {
  id: String
}
type SpendAchPaymentResponse {
  amount: Int!
  descriptor: String!
  id: String!
  status: String!
  transactionIdList: [String]
}
type SpendAddress {
  city: String
  state: String
  street: String
  zip: String
}
type SpendAgreementID {
  id: String
}
type SpendBankAccessCreateResponse {
  id: String
}
type SpendBankAccessDeleteResponse {
  success: Boolean
}
type SpendBankAccount {
  accountId: String
  availableBalance: Float
  currentBalance: Float
  mask: String
  name: String
  officialName: String
  subtype: String
  type: String
}
type SpendBankAccountsResponse {
  externalAccounts: [SpendBankAccount]
}
type SpendBankLinkCreateResponse {
  expiration: String
  linkToken: String
  requestId: String
}
type SpendBankTransaction {
  amount: Int
  canCancel: Boolean
  correlationId: String
  description: String @deprecated(reason: "Can be found in metadata")
  destination: String
  effective: String
  externalId: String
  groupRoster: SpendGroupRoster
  history: [SpendBankTransactionHistory]
  id: String
  metadata: SpendBankTransactionMetaData
  processor: String
  reconciliation: SpendReconciledTransaction
  snapAmount: Int
  source: String
  status: String
  type: String
}
type SpendBankTransactionDetail {
  amount: Int
  canCancel: Boolean
  correlationId: String
  description: String @deprecated(reason: "Can be found in metadata")
  destination: String
  effective: String
  externalId: String
  groupRoster: SpendGroupRoster
  history: [SpendBankTransactionHistory]
  id: String
  metadata: SpendBankTransactionMetaData
  paymentStatus: String
  processor: String
  reconciliation: SpendReconciledTransaction
  snapAmount: Int
  source: String
  status: String
  type: String
}
type SpendBankTransactionHistory {
  date: String
  status: String
  transactionId: String
}
type SpendBankTransactionMetaData {
  account: String
  addenda: String
  customer: String
  description: String
  destination: String
  externalId: String
  invoiceId: String @deprecated(reason: "Can be found in tags as SpendInvoiceIds")
  payment: String
  processor: String
  product: String @deprecated(reason: "Can be found in tags")
  source: String
  status: String
  summary: String
  tags: SpendTransactionTags
}
type SpendBankTransactionResponse {
  transactionDetail: SpendBankTransactionDetail
}
type SpendBankTransactionsResponse {
  count: Int
  transactions: [SpendBankTransaction]
}
type SpendBudget {
  category: SpendCategory!
  createdAt: String!
  description: String!
  id: String!
  invoices: [SpendInvoice!]
  isDefault: Boolean
  reconciledBudgetTotal: Int
  reconciledInvoicesTotal: Int
  reconciledTotal: Int
  reconciledTransactions: [SpendReconciledBudgetTransaction!]
  season: SpendSeason
  targetAmount: Int!
  targetDateAt: String!
  updatedAt: String
  vaultId: String
}
type SpendBudgetID {
  id: String
}
type SpendBudgetResponse {
  budget: SpendBudget
}
type SpendBudgetSummaryResponse {
  summaryByCategory: [SpendCategory]
  summaryUnreconciled: SpendUnreconciledSummary
}
type SpendBudgetsResponse {
  budgets: [SpendBudget]
  count: Int
}
type SpendCategory {
  budgets: [SpendBudget]
  createdAt: String!
  id: String
  isDefault: Boolean!
  isHidden: Boolean!
  name: String!
  organizationId: String!
  type: String!
  updatedAt: String
}
type SpendCategoryID {
  id: String
}
type SpendCategoryResponse {
  categories: [SpendCategory]
  count: Int
}
type SpendCheckDepositTagsResponse {
  success: Boolean!
}
type SpendDeauthorizeResponse {
  id: String
  notifSuccess: Boolean
}
type SpendDebitCard {
  expiration: String
  id: String
  lastFour: String
  status: String
}
type SpendDebitCardID {
  id: String
}
type SpendDebitCardResponse {
  cards: [SpendDebitCard]
  count: Int
}
type SpendExternalTransferResponse {
  amount: Int
  descriptor: String
  id: String
  status: String
}
type SpendGroup {
  accountId: String
  archivedAt: String
  createdAt: String
  hasAccount: Boolean
  id: String
  isArchived: Boolean
  isRequireAgreement: Boolean
  latestSeason: SpendSeason
  name: String
  organizationFees: SpendOrganizationFee
  organizationId: String
  programId: String
  seasons: [SpendSeason]
  seasonsList: [SpendSeason]
}
type SpendGroupAccountBalances {
  active: Int
  archived: Int
}
type SpendGroupID {
  id: String
}
type SpendGroupResponse {
  count: Int
  groups: [SpendGroup]
}
type SpendGroupRoster {
  archivedAt: String
  createdAt: String
  group: SpendGroup
  groupId: String
  id: String
  invite: SpendInvite
  inviteId: String
  invoices: [SpendInvoice]
  isArchived: Boolean
  joinedAt: String
  pastDueDays: Int
  phoneNumber: String
  roster: SpendRoster
  rosterId: String
  season: SpendSeason
  seasonId: String
  status: SpendGroupRosterStatusEnum
  total: SpendTransactionTotals
  userId: String
}
type SpendGroupRosterID {
  id: String
}
type SpendGroupRosterResponse {
  count: Int
  groupRosters: [SpendGroupRoster]
}
type SpendGroupsOverview {
  balance: Int
  cards: [SpendDebitCard]
  collected: Int
  groupId: String
  name: String
  pastDue: Int
  paymentScheduleInvoices: [SpendPaymentSchedule]
  seasonEndAt: String
  seasonStartAt: String
}
type SpendGroupsResponse {
  count: Int
  groups: [SpendGroup]
  hasNext: Boolean
}
type SpendGuardianActiveGroup {
  dueDate: String
  group: SpendGroup
  roster: SpendRoster
}
type SpendGuardianComingSoonInvoice {
  invoiceAmountDue: String
  invoiceAutoPayAuthorized: Boolean
  invoiceDescription: String
  invoiceDueDate: String
  invoiceId: String
  invoicePaymentMethod: String
  invoiceStatus: String
  rosterName: String
  seasonName: String
}
type SpendGuardianCounts {
  activeGroups: Int
  comingSoonInvoices: Int
  recentTransactions: Int
}
type SpendGuardianHighlight {
  activeGroups: [SpendGuardianActiveGroup]
  comingSoonInvoices: [SpendGuardianComingSoonInvoice]
  counts: SpendGuardianCounts
  recentTransactions: [SpendGuardianRecentTransaction]
}
type SpendGuardianRecentTransaction {
  amountDue: String
  dueDate: String
  groupName: String
  invoiceDescription: String
  paymentMethod: String
  paymentStatus: String
  paymentType: String
  rosterName: String
  transactionId: String
}
type SpendInvite {
  createdAt: String
  debitCard: String
  debitCards: [SpendDebitCard!]
  email: String
  expiresAt: String
  firstName: String
  group: SpendGroup
  groupId: String
  id: String
  isArchived: Boolean
  isDeliverable: Boolean
  isUser: Boolean
  lastName: String
  orgName: String
  organizationId: String
  status: String
  type: String
  user: User
  userId: String
}
type SpendInviteID {
  id: String
}
type SpendInviteResponse {
  count: Int
  invites: [SpendInvite]
}
type SpendInvoice {
  amount: Int
  balanceDue: Int
  budgetItem: SpendBudget
  budgetItemId: String
  createdAt: String
  description: String
  dueDate: String
  groupRoster: SpendGroupRoster
  groupRosterId: String
  id: String
  isAutoPayAuthorized: Int
  isOptional: Boolean
  isReconciled: Boolean
  isRefunded: Boolean
  lastNotifyDate: String
  lastNotifyId: String
  note: String
  notificationAttempts: Int
  optedIn: Boolean
  paid: Boolean
  paidDate: String
  paymentMethodId: String
  paymentMethodSource: String
  paymentScheduleInvoiceId: String
  reconciledTransactions: [SpendReconciledInvoiceTransaction]
  refundDate: String
  status: String
  transaction: SpendTransaction
  updatedAt: String
}
type SpendInvoiceID {
  id: String
}
type SpendInvoiceIDs {
  ids: [String]
}
type SpendInvoiceMock {
  amount: Int
  balanceDue: Int
  createdAt: String
  description: String
  dueDate: String
  group: SpendGroup
  id: String
  isReconciled: Boolean
  lastNotifyDate: String
  member: SpendMember
  paid: Boolean
  paidDate: String
  paymentScheduleInvoiceId: String
  season: SpendSeason
  updatedAt: String
}
type SpendInvoiceRefundResponse {
  invoiceId: String
  spendTransactionId: String
}
type SpendInvoiceResponse {
  count: Int
  hasNext: Boolean
  invoices: [SpendInvoice]
}
type SpendMember {
  child: SpendMemberChild
  email: String
  firstName: String
  id: String
  lastName: String
  phoneNumber: String
  signedUp: Boolean
}
type SpendMemberChild {
  id: String
  name: String
}
type SpendMockInvoiceResponse {
  count: Int
  invoices: [SpendInvoiceMock]
}
type SpendNotificationID {
  id: String
}
type SpendNotificationStatus {
  status: String
}
type SpendOrganization {
  achBaseFee: Int
  achPercent: Float
  budgets: [SpendBudget]
  cardBaseFee: Int
  cardPercent: Float
  city: String!
  debitCards: SpendOrganizationDebitCardCount
  email: String!
  externalId: String
  hasLinkedAccount: Boolean
  id: String
  isVerified: Boolean
  legalName: String!
  logo: String
  orgId: String
  owner: SpendOrganizationOwner
  phone: String!
  spendBaseFee: Int
  spendPercent: Float
  state: String!
  street: String!
  userId: String
  website: String
  zip: String!
}
type SpendOrganizationDebitCardCount {
  activated: Int
  assigned: Int
  shipped: Int
  total: Int
}
type SpendOrganizationFee {
  achBaseFee: Int
  achPercent: Float
  cardBaseFee: Int
  cardPercent: Float
  spendBaseFee: Int
  spendPercent: Float
}
type SpendOrganizationID {
  id: String
}
type SpendOrganizationOwner {
  firstName: String
  lastName: String
}
type SpendOrganizationStatus {
  status: Boolean
}
type SpendOrganizationsResponse {
  count: Int
  hasNext: Boolean
  organizations: [SpendOrganization!]
}
type SpendPayNowResponse {
  paymentId: String
  status: String
}
type SpendPaymentMethodDetachResponse {
  paymentMethodId: String
}
type SpendPaymentMethodResponse {
  payment: SpendPayNowResponse
  updatedInvoiceIds: [String]!
}
type SpendPaymentSchedule {
  amountDue: Int
  budgetItem: SpendBudget
  budgetItemId: String
  description: String
  dueDate: String
  group: SpendGroup
  groupId: String
  id: String
  isOptional: Boolean
  note: String
  season: SpendSeason
  seasonId: String
  status: String
}
type SpendPaymentScheduleID {
  id: String
}
type SpendPolicy {
  createdAt: String
  description: String
  name: String
  updatedAt: String
}
type SpendReconcileTransactionID {
  id: String
}
type SpendReconciledBudgetTransaction {
  amount: Int
  budgetItemId: String
  id: String
  reconciledTransaction: SpendReconciledTransaction
  transactionId: String
}
type SpendReconciledInvoiceTransaction {
  amount: Int
  id: String
  invoiceId: String
  reconciledTransaction: SpendReconciledTransaction
  transactionId: String
}
type SpendReconciledTransaction {
  amount: Int
  budgetTransactions: [SpendReconciledBudgetTransaction]
  createdAt: String
  id: String
  invoiceTransactions: [SpendReconciledInvoiceTransaction]
  paymentId: String
  transaction: SpendBankTransaction
  type: String
  updatedAt: String
}
type SpendRole {
  groupId: String
  id: String!
  name: String!
  organizationId: String
  permissions: [String]!
}
type SpendRoleID {
  id: String
}
type SpendRoleResponse {
  count: Int
  roles: [SpendRole]
}
type SpendRoster {
  email: String
  groupRosters: [SpendGroupRoster]
  id: String
  name: String
  total: SpendTransactionTotals
}
type SpendRosterResponse {
  count: Int
  rosters: [SpendRoster]
}
type SpendSeason {
  budgets: [SpendBudget]
  endDateAt: String
  groupId: String
  groupRoster: [SpendGroupRoster]
  id: String
  isBudgetShared: Boolean
  isLinkEnabled: Boolean
  name: String
  paymentScheduleInvoices: [SpendPaymentSchedule]
  paymentScheduleStatus: String
  playerCount: Int
  startDateAt: String
  transactionTotals: SpendTransactionTotals
}
type SpendSeasonID {
  id: String
}
type SpendSession {
  expiresAt: String
  id: String
  message: String
  role: SpendRole
  status: String
  url: String
  userId: String
}
type SpendSessionID {
  id: String
}
type SpendSettings {
  enableGroupBanks: Boolean
  enableProgramAgreements: Boolean
  notifyBankActivityAdmins: Boolean
  notifyDueFrequencies: [String!]
  notifyFailedAchAdmins: Boolean
  notifyPastDueAdmins: Boolean
  notifyPastDueNonUsers: Boolean
  notifyUpcomingNonUsers: Boolean
  pastDueFrequency: Int @deprecated(reason: "replaced by notifyDueFrequencies")
  signUpAgreement: SignupAgreement
  signUpLink: String
}
type SpendSignupFormResponse {
  id: String
  status: String
  type: String
  url: String
}
type SpendTransaction {
  externalId: String
  id: String
  invoiceId: String
  source: String
}
type SpendTransactionAttachmentID {
  id: String
}
type SpendTransactionNoteID {
  id: String
}
type SpendTransactionResponse {
  count: Int
  transactions: [SpendTransaction]
}
type SpendTransactionTags {
  spendAutoPay: Boolean
  spendDestinationId: String
  spendExternalId: String
  spendInvoiceIds: String
  spendOriginalPaymentId: String
  spendPaymentType: String
  spendSourceId: String
  spendUserId: String
}
type SpendTransactionTotals {
  credited: Int
  dueToday: Int
  paid: Int
  pastDue: Int
  pastDueDays: Int
  processing: Int
  statuses: [String]
  upcoming: Int
}
type SpendTransactionsIdList {
  transactionIdList: [String]
}
type SpendUnreconciledSummary {
  credits: TransactionTotalCount
  debits: TransactionTotalCount
}
type SpendUpdateResponse {
  success: Boolean
}
type SpendUserID {
  id: String
}
type SpendUserRoleID {
  id: String
}
type SpendVerificationTokenResponse {
  verificationToken: String
}
type Sponsor {
  assets: [Asset]
  city: String
  email: String
  id: String
  industry: Industry
  logo: String
  name: String
  phone: String
  socialMediaAccounts: SocialMediaAccounts
  state: SponsorState
  status: Boolean
  streetAddress: String
  zipCode: String
}
type SponsorDistrict {
  fields: SponsorDistrictFields
  id: String
  type: String
}
type SponsorDistrictFields {
  name: String
}
type SponsorDistricts {
  districts: [SponsorDistrict]
  totalCount: Int
}
type SponsorInAssets {
  asset: Asset
  assetId: String
  attachment: String
  cartId: Int
  packageId: String
  sponsor: Sponsor
  sponsorId: String
  status: String
}
type SponsorPaymentMethod {
  id: String
  isEnabled: Boolean
  paymentMethodId: String
  sponsorId: String
}
type SponsorSchool {
  fields: SponsorSchoolFields
  id: String!
  type: String
}
type SponsorSchoolFields {
  name: String
  streetAddress: String
  zipCode: String
}
type SponsorSchoolProgram {
  fields: SponsorSchoolProgramFields
  id: String
  type: String
}
type SponsorSchoolProgramFields {
  description: String
  name: String
}
type SponsorSchoolPrograms {
  sponsorSchoolPrograms: [SponsorSchoolProgram]
  totalCount: Int
}
type SponsorSchools {
  schools: [SponsorSchool]
  totalCount: Int
}
type SponsorShipPackage {
  assets: [Asset]
  id: String
  orderId: Int
  orderedAt: String
  receiptPDF: String
  sponsor: Sponsor
  sponsorId: String
  status: String
}
type SponsorState {
  abbreviation: String
  id: String
  name: String
}
type SponsorSubDistrict {
  fields: SponsorDistrictFields
  id: String
  type: String
}
type SponsorSubDistricts {
  subDistricts: [SponsorSubDistrict]
  totalCount: Int
}
type SponsoredSponsorShipGroup {
  assets: [Asset]
  attachments: [Attachment]
  fees: Float
  orderId: String
  orderdate: [String]
  packageId: String
  receiptPDF: String
  sponsorshipgroups: [SponsorshipGroup]
  subTotal: Float
  types: [AssetType]
}
type SponsoredSponsorShipGroups {
  sponsorShipGroups: [SponsoredSponsorShipGroup]
  totalCount: Int
}
type Sponsors {
  sponsors: [Sponsor]
  totalCount: Int
}
type SponsorsOnAssets {
  assetId: String
  assignedAt: String
  attachment: String
  cartId: Int
  sponsorId: String
  status: String
}
type SponsorshipGroup {
  activity: Activity
  assets: [Asset]
  city: String
  description: String
  id: String
  isStripeVerified: Boolean
  logo: String
  message: String
  motive: String
  name: String
  qrCode: String
  schoolId: String
  socialMediaAccounts: SocialMediaAccounts
  state: SponsorState
  status: Boolean
  streetAddress: String
  stripeAccountStatus: String
  stripeConnectAccountId: String
  teamPhoto: String
  zipCode: String
}
type SponsorshipGroupOnOrder {
  assignedAt: String
  assignedBy: String
  package: SponsorShipPackage
  packageId: String
  rejectionReason: String
  sponsorshipGroupId: String
  status: String
}
type SponsorshipGroupOnOrders {
  orders: [SponsorshipGroupOnOrder]
  totalCount: Int
}
type SponsorshipGroupOrdersStats {
  completed: Int
  rejected: Int
  requireApproval: Int
  totalValue: Float
}
type SponsorshipGroups {
  sponsorShipGroups: [SponsorshipGroup]
  totalCount: Int
}
type SponsorshipGroupsOnPackages {
  assignedAt: String
  assignedBy: String
  packageId: String
  rejectionReason: String
  sponsorshipGroupId: String
  status: String
}
type StoreBestSeller {
  productId: Int
  productImage: String
  productName: String
  productPrice: Float
  productQuantity: Int
  productType: String
}
type StoreBrands {
  brands: [Brand]
}
type StoreBuildRequest {
  email: String
  referenceTicket: Int
  storeName: String
  storeRequest: Boolean
  userSsoId: String
}
type StoreCampaign {
  accountManagerId: Int
  commissionEligibleSalesrepId: Int
  endDate: String
  entityId: Int
  fullAddress: String
  gool: Int
  groupLeaderEmail: String
  id: Int
  initialGoalCents: Int
  joinCode: Int
  name: String
  originalSalesrepId: Int
  salesrepId: Int
  settlementConfirmationStatus: String
  settlementMethod: String
  settlementStatus: String
  slug: String
  startDate: String
  status: String
  teamSize: Int
  totalRaisedCents: Int
  userDirectoryId: String
}
type StoreEditInfo {
  code: String
  scopeId: Int
}
type StoreOrderItemImage {
  imageUrl: String
  itemId: BigInt
  selectedLogo: String
}
type StoreOrderItems {
  items: [StoreOrderItemImage]
}
type StoreOrderSalesGraphs {
  graphs: [storeOrderSalesGraph]
}
type StoreParticipant {
  email: String
  firstName: String
  lastName: String
  phoneNumber: String
}
type StorePaymentIntent {
  clientSecret: String
  email: String
  userSsoId: String
}
type StoreProductGroupsAndColors {
  colors: [ProductGroupAndColors]
}
type StoreReceiverData {
  email: String
  points: Float
  receiverId: BigInt
}
type StoreScopeBestSeller {
  bestSellers: [StoreBestSeller]
}
type StoreSenderData {
  email: String
  points: Float
  senderId: BigInt
}
type StoreSubscribedUser {
  isSubscribed: Boolean
}
type StoreTicket {
  createdAt: String
  id: String
  message: String
  scopeId: Int
  subject: String
  ticketId: String
  updatedAt: String
}
type StoreTickets {
  tickets: [StoreTicket]
}
type StoreTransaction {
  amount: Float
  email: String
  id: String
  points: Float
  scopeId: Int
  status: String
  transactionId: String
  userSsoId: String
}
type StoreTransferReturn {
  points: Float
  receiver: StoreReceiverData
  sender: StoreSenderData
  status: String
}
type StoreUser {
  email: String
  firstName: String
  lastName: String
  points: Float
  userId: BigInt
}
type StoreUserCampaigns {
  campaigns: [StoreCampaign]
  pagination: SDPagination
}
type StoreUserParticipants {
  pagination: SDPagination
  participants: [StoreParticipant]
}
type StoresFilter {
  pagination: SDPagination
  stores: [MagentoStore]
}
type StoresSummary {
  baseSales: Float
  orders: BigInt
  points: Float
  sales: Float
  stores: BigInt
}
type StripeAccount {
  accountId: String!
  accountType: AccountType
  campaignId: String!
}
"See CampaignMembership for details"
type SupporterCampaign {
  id: ID!
}
type Team {
  facility: String
  gender: String
  groupval: String
  home_field: String
  is_deleted: Boolean
  level1: String
  sport_code: String!
  sport_description: String
  sport_name: String!
}
type TemplateOfficial {
  id: Int!
  pay: Float
  pay_code: String
  sport: String
  worker_duty: String
}
type TemplatePreparation {
  id: Int!
  prep: Int
  preparation_id: String
  preparation_name: String
  qty: String
  sport: String
}
type TemplateWorker {
  home_field: String
  id: Int!
  pay: Float
  pay_code: String
  sport: String
  worker_duty: String
  worker_name: String
}
type Total {
  salary: String
  woker_name: String
}
type Transaction {
  amount: Decimal
  correlationId: String
  created: Timestamp
  description: String
  destination: String
  effective: Timestamp!
  externalId: String!
  id: UUID!
  metadata: JSON
  processor: String
  snapAmount: Decimal
  source: String
  status: String!
  type: String
}
type TransactionAttachment {
  createdAt: String
  description: String
  id: String
  lastUpdatedByUserId: String
  name: String
  paymentId: String
  updatedAt: String
  url: String
}
type TransactionAttachmentsResponse {
  attachments: [TransactionAttachment]
}
type TransactionDetail {
  amount: Decimal
  description: String!
  destination: String
  externalId: String!
  history: [TransactionHistoryEvent]!
  id: UUID!
  metadata: JSON
  processor: String
  snapAmount: Decimal
  source: String
  type: String
}
type TransactionHistoryEvent {
  date: Timestamp!
  status: Status!
  transactionId: UUID!
}
type TransactionNotes {
  content: String
  createdAt: String
  id: String
  lastUpdatedByUserId: String
  paymentId: String
  updatedAt: String
}
type TransactionNotesResponse {
  notes: [TransactionNotes]
}
type TransactionTotalCount {
  count: Int
  total: Int
}
type TransformedDailyCalendarBusSchedule {
  calendar: [String]
  events: [DailyCalendarBusScheduleEvents]
  exportdata: [DailyCalendarBusScheduleExportData]
}
type TransformedDailyCalendarEventReturn {
  activity: String
  activityLevel: String
  activityType: String
  author: String
  bus_fee: Int
  bus_time: String
  comments: String
  conference: String
  conference_event_id: Int
  conference_id: Int
  confirmed: String
  confirmedStatusBoolean: Boolean
  contract: String
  departure_location: String
  directions: String
  duty: String
  early_dismissal_required: String
  early_dismissal_time: String
  email: String
  end_time: String
  estimated_return_time: String
  event: String
  eventOfficial: String
  eventOfficialCell: String
  eventOfficialEmail: String
  eventTiming: String
  event_date: String
  event_id: Int
  exists_in_mls: Int
  fee: Int
  formatedEventDate: String
  formatedEventDateSystem: String
  formatedEventDay: String
  g_s: String
  gate_revenue: Int
  groupval: String
  headline: String
  impact_event: String
  isDuplicate: String
  lead: String
  location: String
  loss_points: Int
  noofgames: String
  num_buses: Int
  num_buses_text: String
  opponent: String
  opponent_code: String
  opponent_score: String
  pay_code: String
  picture: String
  place: String
  prep_setup: String
  promote: String
  results: String
  revenue: Int
  rollover: String
  rolloverStatusBoolean: Boolean
  salary: Int
  seasonInfo: String
  seasonSportCode: String
  season_team: Int
  serialnumber: String
  sportCode: String
  sportDescription: String
  sportGender: String
  sportLevel: String
  sportName: String
  start_time: String
  team_score: String
  title: String
  tournament: String
  trans_id: Int
  transportDetails: String
  transport_comments: String
  transportation: String
  vehicle_count: String
  vehiclesTransportDetails: [DailyCalendarEventTransportDetails]
  web_dir: String
  weekdayname: String
  win_points: Int
  years: String
}
type TransformedDailyCalendarOfficials {
  exportdata: [DailyCalendarOfficialExport]
  message: [DailyCalendarOfficialMessage]
}
type TransformedDailyCalendarPreparation {
  exportdata: [DailyCalendarPreparationExportData]
  message: [DailyCalendarPreparationMessage]
}
type TransformedDailyCalendarWorkers {
  exportdata: [DailyCalendarWorkerExportData]
  message: [DailyCalendarWorkerMessage]
}
type TransformedEventReturn {
  activity: String
  activityLevel: String
  activityType: String
  author: String
  bus_fee: Int
  bus_time: String
  comments: String
  conference: String
  conference_event_id: Int
  conference_id: Int
  confirmed: String
  confirmedStatusBoolean: Boolean
  contract: String
  departure_location: String
  directions: String
  duty: String
  early_dismissal_required: String
  early_dismissal_time: String
  email: String
  end_time: String
  estimated_return_time: String
  event: String
  eventOfficial: String
  eventOfficialCell: String
  eventOfficialEmail: String
  eventTiming: String
  event_date: String
  event_id: Int
  exists_in_mls: Int
  fee: Int
  formatedEventDate: String
  formatedEventDateSystem: String
  formatedEventDay: String
  g_s: String
  gate_revenue: Int
  groupval: String
  headline: String
  impact_event: String
  isDuplicate: String
  lead: String
  location: String
  loss_points: Int
  noofgames: String
  num_buses: Int
  num_buses_text: String
  opponent: String
  opponent_code: String
  opponent_score: String
  pay_code: String
  picture: String
  place: String
  prep_setup: String
  promote: String
  results: String
  revenue: Int
  rollover: String
  rolloverStatusBoolean: Boolean
  salary: Int
  seasonInfo: String
  seasonSportCode: String
  season_team: Int
  serialnumber: String
  sportCode: String
  sportDescription: String
  sportGender: String
  sportLevel: String
  sportName: String
  start_time: String
  team_score: String
  title: String
  tournament: String
  trans_id: Int
  transportDetails: String
  transport_comments: String
  transportation: String
  vehicle_count: String
  web_dir: String
  weekdayname: String
  win_points: Int
  years: String
}
type TransformedOfficialAssignment {
  duty: String
  eventActivity: String
  eventDate: String
  eventHomeAway: String
  eventLocation: String
  eventOpponent: String
  eventTime: String
  event_id: Int
  id: Int
  name: String
  organization: String
  paid: String
  pay_code: String
  salary: Int
  seasonSportCode: String
  sportDescription: String
  ssn: String
}
type TransportType {
  recipient: String
  transport: TransportEnum
}
type UnconfirmedEvents {
  activity: String
  bus_count: Int
  comments: String
  confirmed: String
  driver_name: String
  driver_phone: String
  end_time: String
  event_date: String
  facility: String
  g_s: String
  gender: String
  home_field: String
  id: Int
  levels: String
  opponent: String
  place: String
  season_id: Int
  sports_code: String
  sports_description: String
  sports_group: String
  sports_name: String
  start_time: String
  vehicle_id: String
  vehicle_type: String
  year: String
}
type UnconfirmedEventsList {
  items: [UnconfirmedEvents]
  limit: Int
  offset: Int
  totalFilteredItems: Int
  totalPages: Int
  totalRows: Int
}
"Unit API"
type UnitBusinessApplicationResponse {
  applicationId: String!
  customerId: String
}
type UpdatedFundraiserStoreUrl {
  id: Int
}
type UpdatedParticipantGroupCount {
  count: Int
}
type UpsertEventParticipantsCount {
  count: Int
}
type UpsertEventPreparationsCount {
  count: Int
}
type UpsertEventTransportDetailsCount {
  count: Int
}
type User {
  apps: [String]
  email: String
  firstName: String
  id: String
  isConfirmed: Boolean
  isDisabled: Boolean
  kyc: VaultKyc
  language: String
  lastName: String
  occupation: UserOccupation
  phoneNumber: String
  profilePicture: String
  snapRaiseId: String @deprecated(reason: "will be removed in the next release")
  snapSpendId: String @deprecated(reason: "will be removed in the next release")
  walletOrganization: Organization
  walletTerms: Boolean
}
type UserChallenge {
  completedAt: String
  id: String!
  name: String!
  params: JSONObject
  skippedAt: String
  status: UserChallengeStatus!
}
type UserFitting {
  fitting: String
  id: ID!
}
type UserInviteResponse {
  redirect: String
}
type UserNode {
  createdAt: DateTime
  id: ID!
  internal: Boolean
  role: ID
  type: [String]
  updatedAt: DateTime
}
type UserPermission {
  id: String!
  scope: String
}
type UserPermissionsList {
  id: String
  negativePermissions: [UserPermission]
  permissions: [UserPermission]
  roleIds: [String]
}
type UserPublic {
  firstName: String
  id: String
  isInternal: Boolean
  lastName: String
  notMigrated: Boolean
  profilePicture: String
}
type UserResetPasswordResponseWithAvailableTransport {
  availableTransport: [TransportEnum!]!
  info: String
  result: [TransportType!]!
}
type UserSavedRep {
  snapRepEmail: String
  uuId: String
}
type UserWithPermissions {
  apps: [String]
  email: String
  firstName: String
  hasFamily: Boolean
  id: String
  kyc: VaultKyc
  language: String
  lastName: String
  occupation: UserOccupation
  parent: String @deprecated(reason: "use parents instead of parent")
  parents: [String]
  permissions: [String]
  phoneNumber: String
  profilePicture: String
  snapRaiseId: String @deprecated(reason: "will be removed in the next release")
  snapSpendId: String @deprecated(reason: "will be removed in the next release")
  walletOrganization: Organization
  walletTerms: Boolean
}
type Users {
  nextPage: Boolean
  users: [User]
}
type VaultAccountStatus {
  accountRepresentativeRequirements: VaultEntityRequirements
  beneficialOwnersRequirements: [VaultEntityRequirements!]
  kybRequirements: VaultEntityRequirements
  valid: Boolean!
}
"Used for addresses in VaultKyb and VaultKyc"
type VaultAddress {
  city: String!
  postalCode: String!
  region: String!
  street: String!
  unit: String
}
type VaultBankAccount {
  account_holder_name: String!
  account_holder_type: String!
  bank_name: String!
  country: String!
  currency: String!
  default_for_currency: Boolean!
  fingerprint: String!
  id: ID!
  last4: String!
  routing_number: String!
  status: String!
}
"Additional data passed into the Stripe api Can be read in Stripe dashboard"
type VaultCardMetadata {
  description: String
  walletId: String
}
"Day, Month and Year of birth"
type VaultDob {
  day: String
  month: String
  year: String
}
type VaultEntityRequirements {
  missingFields: [String!]!
  requiredDocuments: [VaultRequiredDocument!]!
}
"Organizations/Companies"
type VaultKyb {
  address: VaultAddress!
  customerFacingName: String!
  description: String!
  email: String
  entityDocument: String
  id: ID!
  legalName: String!
  phoneNumber: String!
  structure: KYB_STRUCTURE!
  taxId: String!
  type: KYB_TYPE!
  url: String!
}
"Individuals"
type VaultKyc {
  address: VaultAddress!
  director: Boolean
  dob: VaultDob!
  email: String!
  executive: Boolean
  firstName: String!
  id: ID!
  lastName: String!
  owner: Boolean
  "If owner=true, percentOwnership is required"
  percentOwnership: Int
  phoneNumber: String!
  representative: Boolean
  ssn: String
  title: String
}
type VaultMutationError {
  message: String!
  type: String
}
type VaultMutationResponse {
  errors: [VaultMutationError]
  success: Boolean!
}
type Vehicle {
  id: Int!
  is_deleted: Boolean
  status: String
  vehicle_type: String
}
type WalletConfirmOrganizationInfoResult {
  organization: Organization
  user: UserWithPermissions
}
type WalletUserRegisterResult {
  error: String
  user: User
}
type WinbackDeals {
  activity: String
  amount: String
  closedLost: String
  dealName: String
  dealStage: String
  hubspotId: String
  id: String
  isWinbackPinned: Boolean
  lastLaunch: String
  leaderFirstName: String
  leaderLastName: String
  previousDealId: String
  previousFundId: String
}
type Worker {
  duty: String
  email: String
  event: Event
  event_id: Int
  id: Int!
  organization: String
  paid: String
  pay_code: String
  pay_rate: Float
  salary: Float
  ssn: String
  woker_name: String
  worker_end_time: String
  worker_start_time: String
  worker_type: String
}
type WorkerDeleteManyCount {
  count: Int
}
type WorkerPool {
  Address: String
  City: String
  First: String
  Home_Phone: String
  ID: Int!
  Last: String
  SSN: String
  State: String
  Work_Phone: String
  Zip: String
  cell_phone: String
  email: String
  is_deleted: String
  pay_rate: Float
  worker_type: String
}
type WorkerUpsertManyCount {
  count: Int
}
type busSchedules {
  activity: String
  bus_count: Int
  bus_departure_location: String
  bus_early_dismissal_time: String
  bus_estimated_return_time: String
  bus_time: String
  cancellation_status: String
  comments: String
  confirmed: String
  end_time: String
  event_date: String
  event_transport_details: [DailyCalendarEventTransportDetails]
  facility: String
  g_s: String
  gender: String
  home_field: String
  id: Int
  levels: String
  opponent: String
  place: String
  season_id: Int
  sports_code: String
  sports_description: String
  sports_group: String
  sports_name: String
  start_time: String
  vehicle_type: String
}
type driveGetListCurrentCustomersReturn {
  offset: Int
  results: [CurrentCustomersDeals]
  totalCount: Int
}
type driveGetListPotentialCustomersReturn {
  offset: Int
  results: [PotentialCustomersDeals]
  totalCount: Int
}
"Last clicked tracking information used by Drive's Get List Application"
type driveOrgUserTrackingReturn {
  "ID of the organization."
  orgId: String
  "A unique tracking id"
  trackingId: String
  trackingType: String
  "The value of the tracking type"
  trackingValue: String
  trackingValueType: String
  "ID of the user."
  userId: String
}
type multipleCreationResponse {
  count: Int
}
type mySponsorships {
  packages: [packages]
  totalCount: Int
}
type packageAsset {
  asset: Asset
}
type packages {
  id: String
  orderId: String
  orderedAt: String
  packages: [packageAsset]
}
type sponsoredOrders {
  orders: [sponsorshipOrders]
  totalCount: Int
}
type sponsorshipGroupUser {
  sponsorshipGroupId: String
  userId: String
  userType: String
}
type sponsorshipOrders {
  assets: [Asset]
  id: String
  orderId: String
  sponsorshipGroups: [SponsorshipGroupsOnPackages]
}
type storeOrderSalesGraph {
  baseTotalSales: Float
  endDate: String
  scopeId: BigInt
  startDate: String
  totalOrders: BigInt
  totalSales: Float
}
type sumResponse {
  sum: Float
}
""
type twispCardBalances {
  ""
  allTxs: [twispTransactions]
  ""
  authorization_balance: Int64
  ""
  balance: Int64
  ""
  card_id: String
  ""
  card_limit: Int64
  ""
  history(limit: Int32 = "1000", sort: Sort): [twispCardBalances]
  ""
  seq: Uint64
  ""
  settled_balance: Int64
  ""
  visibleTxs: [twispTransactions]
}
""
type twispCards {
  ""
  card_id: String
  ""
  history(limit: Int32 = "1000", sort: Sort): [twispCards]
  ""
  last4: String
  ""
  seq: Uint64
}
""
type twispStripeHooks {
  ""
  account: String
  ""
  api_version: String
  ""
  created: Int64
  ""
  data(expression: String = "this"): JSON
  ""
  history(limit: Int32 = "1000", sort: Sort): [twispStripeHooks]
  ""
  id: String
  ""
  livemode: Boolean
  ""
  object: String
  ""
  pending_webhooks: Int64
  ""
  processed: Timestamp
  ""
  request(expression: String = "this"): JSON
  ""
  seq: Uint64
  ""
  type: String
}
""
type twispTransactions {
  ""
  amount: Int64
  ""
  card_id: String
  ""
  correlation: String
  ""
  created: Int64
  ""
  description: String
  ""
  event_created: Int64
  ""
  history(limit: Int32 = "1000", sort: Sort): [twispTransactions]
  ""
  id: String
  ""
  last4: String
  ""
  meta(expression: String = "this"): JSON
  ""
  seq: Uint64
  ""
  status: String
  ""
  visible: Boolean
}
interface DriveUser {
  email: String
  firstName: String
  lastName: String
}
interface Tokens {
  accessToken: String
  refreshToken: String
}
union Account = ExternalBankAccount | StripeAccount
"CampaignMembership is our way of securing information based on a users membership type. When a user queries campaignMemberships they can get information on their memberships based on who they are as defined in the JWT. Example of how to use:https://www.notion.so/snap-mobile/Campaign-1b4c4a055bc84aaf8290f078f57a5193"
union CampaignMembership = AdminCampaign | GroupLeaderCampaign | ParticipantCampaign | SupporterCampaign
union MagentoOrderUnionType = MagentoOrders | OnException
union MagentoPointActivityUnionType = MagentoPointActivities | OnException
union MagentoStorePointsEarnedUnionType = MagentoStoresPointsEarned | OnException
union MagentoStoreUnionType = MagentoStore | OnException
union OrdersFilterUnionType = OnException | OrdersFilter
union OrdersSummaryUnionType = OnException | OrdersSummary
union Payout = Check | Deposit
union PointActivityFilterUnionType = OnException | PointActivityFilter
union ShipmentExternalId = ShipmentCampaignId | ShipmentOtherId
union StoreBaseSellerUnionType = OnException | StoreScopeBestSeller
union StoreBrandsUnionType = OnException | StoreBrands
union StoreBuildRequestUnionType = OnException | StoreBuildRequest
union StoreEditInfoUnionType = OnException | StoreEditInfo
union StoreFilterUnionType = OnException | StoresFilter
union StoreManagerUpdatePointsUnionType = MagentoStoreManager | OnException
union StoreOrderItemsUnionType = OnException | StoreOrderItems
union StorePaymantIntentUnionType = OnException | StorePaymentIntent
union StoreProductGroupsAndColorsUnionType = OnException | StoreProductGroupsAndColors
union StoreSubscribedUserUnionType = OnException | StoreSubscribedUser
union StoreTicketUnionType = OnException | StoreTickets
union StoreTicketsUnionType = OnException | StoreTicket
union StoreTransactionUnionType = OnException | StoreTransaction
union StoreTransferPointsUnionType = OnException | StoreTransferReturn
union StoreUserCampaignUnionType = OnException | StoreUserCampaigns
union StoreUserInfoUnionType = OnException | StoreUser
union StoreUserParticipantUnionType = OnException | StoreUserParticipants
union StoresSummaryUnionType = OnException | StoresSummary
union storeOrderSalesGraphUnionType = OnException | StoreOrderSalesGraphs
enum AccountType {
  EXTERNAL_BANK
  "more TK"
  STRIPE
}
enum BasicCampaignStatus {
  ACTIVE
  CLOSED
  UPCOMING
}
enum CARD_STATUS {
  active
  canceled
  inactive
}
enum CARD_TYPE {
  physical
  virtual
}
"Fixed statuses for a campaigns kyc"
enum CampaignKycStatus {
  action_required
  in_review
  require_docs
  unsubmitted
  unverified
  verified
}
enum CampaignKycStatusEnum {
  ACTION_NEEDED
  PENDING
  UNSUBMITTED
  VERIFIED
}
"Fixed type for a campaigns kyc"
enum CampaignKycType {
  stripe
  wepay
}
enum CampaignMemberAssociation {
  ADMIN
  COACH
  COCOACH
  COPARTICIPANT
  PARTICIPANT
  SUPPORTER
}
enum CampaignStatus {
  ACTIVE
  APPROVED
  ARCHIVE
  CLOSED
  DELETED
  FINAL
  PENDING_APPROVAL
  SETTLED
}
enum CategoryFilterEnum {
  name
  type
}
enum CategoryTypeEnum {
  expense
  income
}
enum CheckStatus {
  DEPOSITED
  "TODO(SHR): update this once we get actual statuses from bill.com"
  PROCESSING
  SENT
}
enum ContactTemplateMedium {
  EMAIL
  TEXT_MESSAGE
}
enum ContactTemplateType {
  GROUP_LEADER
  PARTICIPANT
}
enum DonationLevels {
  FIVE
  FOUR
  ONE
  SIX
  THREE
  TWO
}
enum DriveAttendanceStatus {
  ATTENDING
  NOT_ATTENDING
}
enum DriveEventStatus {
  CLOSED
  EMAIL_SENT
  NOT_ATTENDING
  PENDING
  REGISTERED
}
enum DriveFieldType {
  HTML
  LINK
  TEXT
}
enum EventAttendeeRequestStatus {
  NO_REQUEST
  PROCESSED
  REQUEST
}
enum EventDateStatus {
  Active
  Closed
  Upcoming
}
enum ExternalTransferDirectionEnum {
  Credit
  Debit
}
"Owned by Vault Only used in legacy createCard"
enum FINANCIAL_GATEWAY {
  stripe
}
enum FUNDRAISER_STATUS {
  active
  approved
  archive
  closed
  deleted
  final
  pending_approval
  settled
}
enum FinAcctStatus {
  ACTION_REQUIRED
  ACTIVE
  APPROVED
  AWAITING_REAPPROVAL
  DECLINED
  PENDING
  TERMINATED
  UNDER_REVIEW
}
enum GroupRosterFilterEnum {
  groupId
  id
  memberId
  rosterId
  seasonId
}
enum HubspotSortDirection {
  ASCENDING
  DESCENDING
}
enum InviteFilterEnum {
  group
  program
  status
  type
}
enum InvoiceFilterEnum {
  date
  groupId
  groupName
  groupRosterId
  playerName
  status
  unreconciled
}
enum InvoiceReportFilterEnum {
  dateAfter
  dateBefore
  groupId
  groupRosterId
  pastDueRange
  status
}
enum KYB_STRUCTURE {
  free_zone_establishment
  free_zone_llc
  government_instrumentality
  governmental_unit
  incorporated_non_profit
  limited_liability_partnership
  llc
  multi_member_llc
  private_company
  private_corporation
  private_partnership
  public_company
  public_corporation
  public_partnership
  single_member_llc
  sole_establishment
  sole_proprietorship
  tax_exempt_government_instrumentality
  unincorporated_association
  unincorporated_non_profit
}
enum KYB_TYPE {
  company
  government_entity
  individual
  non_profit
}
enum OrderStatus {
  APPROVED
  COMPLETE
  PROCESSING
  REJECTED
  REQUIRE_APPROVAL
}
enum OrderType {
  ASC
  DESC
}
enum OrgType {
  BOOSTER
  BUSINESS
  DISTRICT
  FOUNDATION
  PROGRAM
  PTA
  SCHOOL
  TEAM
}
enum OrganizationFilterEnum {
  pending
}
enum PREFUND_STATUS {
  Active
  Closed
  Pending
}
enum PagesNameEnum {
  AboutUs
  Mission
  Recruitment
  SchoolDirections
  Sponsors
  Staff
}
enum PaymentsApiCustomerPaymentMethodType {
  BANK
  CARD
  OTHER
}
enum Processor {
  STRIPE
  UNIT
}
enum Product {
  CONNECT
  INSIGHTS
  MANAGE
  RAISE
  SPEND
  SPONSOR
  STORE
}
enum ResponseStatus {
  FAILURE
  SUCCESS
}
enum RosterFilterEnum {
  groupName
  memberName
  rosterName
  seasonName
}
enum SHIPPING_SERVICE {
  express
  priority
  standard
}
"Owned by Vault Only used in legacy createCard"
enum SPENDING_LIMIT_INTERVAL {
  all_time
  daily
  monthly
  per_authorization
  weekly
  yearly
}
enum SUPPORT_TICKET_DEPARTMENT {
  ACCOUNTS
  HUBSPOT
  IT
  PEP
  SALES
  SPONSOR
  WALLET
  WAREHOUSE
}
enum SalesrepType {
  ACCOUNT_MANAGER
  SALES_REP
}
enum SchoolCategory {
  CHARTER
  MAGNET
  PRIVATE
  PUBLIC
}
"Fixed statuses for a campaigns settlement status"
enum SettlementStatus {
  IN_REVIEW
  UNSUBMITTED
  VERIFIED
}
enum ShipmentCarrier {
  FEDEX
  UNKNOWN
  USPS
}
enum ShipmentSource {
  OTF
  OTK_INCENTIVE
  STORE
}
enum ShipmentStatus {
  PROCESSING
  SHIPPED
}
""
enum Sort {
  ""
  ASC
  ""
  DESC
}
enum SortDirection {
  ASC
  DESC
}
enum SortField {
  CLOSED_STATUS
  DAYS_LEFT
  END_DATE
  KYC_STATUS
  NAME
  PARTICIPATION
  PRELOAD
  SETTLEMENT_DETAILS
  START_DATE
  STATUS
  TOTAL_RAISED
}
enum SortOrderEnum {
  asc
  desc
}
enum SpendGroupRosterStatusEnum {
  autopay_stop
  awaiting_approval
  no_invite
  not_signed_up
  paid
  past_due
}
enum SpendInviteType {
  group_staff
  guardian
  program_admin
  program_observer
  program_staff
}
enum SpendRoleNameEnum {
  group_staff
  guardian
  program_observer
  program_staff
}
enum SpendSortOrderEnum {
  ASC
  DESC
}
enum State {
  ALABAMA
  ALASKA
  ARIZONA
  ARKANSAS
  CALIFORNIA
  COLORADO
  CONNECTICUT
  DELAWARE
  DISTRICT_OF_COLUMBIA
  FLORIDA
  GEORGIA
  HAWAII
  IDAHO
  ILLINOIS
  INDIANA
  IOWA
  KANSAS
  KENTUCKY
  LOUISIANA
  MAINE
  MARYLAND
  MASSACHUSETTS
  MICHIGAN
  MINNESOTA
  MISSISSIPPI
  MISSOURI
  MONTANA
  NEBRASKA
  NEVADA
  NEW_HAMPSHIRE
  NEW_JERSEY
  NEW_MEXICO
  NEW_YORK
  NORTH_CAROLINA
  NORTH_DAKOTA
  OHIO
  OKLAHOMA
  OREGON
  PENNSYLVANIA
  RHODE_ISLAND
  SOUTH_CAROLINA
  SOUTH_DAKOTA
  TENNESSEE
  TEXAS
  UTAH
  VERMONT
  VIRGINIA
  WASHINGTON
  WEST_VIRGINIA
  WISCONSIN
  WYOMING
}
enum StateCode {
  AK
  AL
  AR
  AS
  AZ
  CA
  CO
  CT
  DC
  DE
  FL
  GA
  GU
  HI
  IA
  ID
  IL
  IN
  KS
  KY
  LA
  MA
  MD
  ME
  MI
  MN
  MO
  MP
  MS
  MT
  NC
  ND
  NE
  NH
  NJ
  NM
  NV
  NY
  OH
  OK
  OR
  PA
  PR
  RI
  SC
  SD
  TN
  TX
  UM
  UT
  VA
  VI
  VT
  WA
  WI
  WV
  WY
}
enum Status {
  PENDING
  SETTLED
}
enum StripeEnv {
  RAISE
  SPEND
}
enum TransactionFilterEnum {
  date
  groupName
  method
  reconciledStatus
  seasonName
  status
  type
}
enum TransactionReportFilterEnum {
  dateAfter
  dateBefore
  groupIdOrgId
  method
  status
  type
}
enum TransportEnum {
  email
  sms
}
enum UserApps {
  connect
  drive
  home
  insights
  manage
  raise
  spend
  sponsor
  store
  wallet
}
enum UserChallengeStatus {
  AWAITING
  COMPLETED
  SKIPPED
}
enum UserFittingPreference {
  MENS
  WOMENS
}
enum UserInviteStatus {
  ACCEPTED
  DECLINED
  PENDING
}
enum UserOccupation {
  district_administrator
  financial_administrator
  group_leader
  other
  parent
  school_director
  state_administrator
  student_or_participant
  unknown
}
"Current status of card"
enum VaultCardStatus {
  active
  "To deactivate a card set it to canceled"
  canceled
  "Cards ship inactive"
  inactive
}
"Is the card physical (needs to mailed out) or virtual"
enum VaultCardType {
  physical
  virtual
}
enum VaultDocumentProvider {
  stripe
  unit
}
"Third party financial providers"
enum VaultFinancialProvider {
  stripe
  unit
}
enum VaultPayoutInterval {
  daily
  weekly
}
enum VaultRequiredDocument {
  "Utility bill, bank statement, lease agreement or current pay stub"
  address_verification
  "Bank Statement or Void Check"
  bank_account_document
  "Certificate of incorporation or certificate of assumed name"
  certificate_of_incorporation
  "IRS form 147c or IRS form CP-575"
  ein_confirmation
  "Passport or Drivers License"
  id_document
  "Passport, Drivers License or State ID"
  id_document_or_passport
  "501C3 or SS4"
  irs_determination_letter
  "Passport"
  passport
  "Power of attorney"
  power_of_attorney
  "SSN Card"
  ssn_card
}
"How to send a physical VaultCard"
enum VaultShippingService {
  express
  priority
  standard
}
"The interval that the spending limit interval of a card is reset"
enum VaultSpendingLimitInterval {
  all_time
  daily
  monthly
  per_authorization
  weekly
  yearly
}
enum VaultWeeklyAnchor {
  friday
  monday
  saturday
  sunday
  thursday
  tuesday
  wednesday
}
enum WorkerTypes {
  c
  h
}
"Indexes for table twispCardBalances"
enum twispCardBalances_indexes {
  ""
  card_id
}
"Indexes for table twispCards"
enum twispCards_indexes {
  ""
  card_id
}
"Indexes for table twispStripeHooks"
enum twispStripeHooks_indexes {
  ""
  id
}
"Indexes for table twispTransactions"
enum twispTransactions_indexes {
  ""
  card_id
  ""
  card_id_viz
  ""
  id
}
input AccountTransactionsInput {
  accountId: String!
  createdAfter: Timestamp
  createdBefore: Timestamp
  externalId: String
  metadata: JSONObject
  status: Status
}
input CommonCalendarFiltersInput {
  activity: String
  endDate: Date
  facilities: [String]
  gender: String
  group: String
  homeAway: String
  levels: [String]
  opponents: [String]
  startDate: Date
  teams: [String]
  vehicleType: String
}
input CommonGridFiltersInput {
  endDate: Date
  facilities: [String]
  gender: String
  levels: [String]
  startDate: Date
  teams: [String]
}
input CommonSchedulesFiltersInput {
  activity: String
  activityName: [String]
  endDate: Date
  facilities: [String]
  gender: String
  group: String
  homeAway: String
  levels: [String]
  opponents: [String]
  startDate: Date
  vehicleType: String
}
input CommonSheetFiltersInput {
  activity: String
  endDate: Date
  facilities: [String]
  gender: String
  group: String
  homeAway: String
  levels: [String]
  opponents: [String]
  startDate: Date
  teams: [String]
  vehicleType: String
}
input Connect {
  connect: ConnectID
}
input ConnectID {
  id: String
}
input CreateEventInput {
  activity: String
  author: String
  bus_fee: Float
  bus_time: String
  cancellation_status: String
  comments: String
  conference: String
  conference_event_id: Int
  conference_id: Int
  confirmed: String
  contract: String
  created_at: Date
  departure_location: String
  directions: String
  early_dismissal_required: String
  early_dismissal_time: String
  end_time: String
  estimated_return_time: String
  event_date: Date
  event_id: Int
  exists_in_mls: Int
  fee: Float
  g_s: String
  gate_revenue: Float
  headline: String
  impact_event: String
  lead: String
  location: String
  loss_points: Int
  num_buses: Int
  opponent: String
  opponent_code: String
  opponent_score: String
  picture: String
  place: String
  prep_setup: String
  promote: String
  results: String
  revenue: Float
  rollover: String
  season_team: Int
  start_time: String
  team_score: String
  title: String
  tournament: String
  trans_id: Int
  transport_comments: String
  transportation: String
  update_at: Date
  web_dir: String
  win_points: Int
  years: String
}
input CreateEventParticipantsInput {
  contract_received: String
  event_id: Int
  id: Int
  notes: String
  paid: String
  school_code: String
}
input CreateEventPreparationInput {
  comments: String
  event: Int
  id: Int!
  prep: String
  qty: String
}
input CreateEventTransportDetailsInput {
  driver_name: String
  driver_phone: String
  event_id: Int
  id: Int!
  vehicle_id: String
  vehicle_type: String
}
input CreateFacilityInput {
  Address1: String!
  Address2: String
  City: String!
  State: String!
  ZipCode: String!
  directions: String
  indoor: String
  ml_site_id: String
  ml_space: String
  ml_space_id: String
  picture: String
  place_name: String!
  show: String
  web: String
}
input CreateInviteSponsorshipGroupRelation {
  create: [SponsorshipGroupConnect]
}
input CreateLevelInput {
  Level: String
  is_deleted: Boolean
}
input CreateOfficialDutyInput {
  duty: String
  is_deleted: Boolean
}
input CreateOfficialInput {
  duty: String
  event_id: Int
  id: Int!
  offic_id: String
  organization: String
  paid: String
  pay_code: String
  received: String
  salary: Float
  ssn: String
  voucher_number: String
  worker_name: String
}
input CreateOfficialPoolByIdInput {
  Address: String
  City: String
  First: String!
  Home_Phone: String
  ID: String!
  Last: String!
  SSN: String
  State: String
  Work_Phone: String
  Zip: String
  cell_phone: String
  email: String
  vendor_number: String
}
input CreateOpponentInput {
  Address: String
  Phone: String
  SchoolCode: String!
  SchoolName: String
  State: String
  Zip: String
  ad_name: String
  city: String
  email: String
  fax: String
  nces_id: String
  non_school: Boolean
}
input CreatePreparationInput {
  duty: String
  id: Int!
  is_deleted: Boolean
  qty: String
}
input CreateSchoolInfoInput {
  Schoolname: String
  ad: String
  ad_contract_signee: String
  address: String
  ccemail: String
  city: String
  conf_text_type: String
  email: String
  email_reminder: String
  email_reminder_officials: String
  email_reminder_workers: String
  enable_cc_email_as_origin: String
  enable_ml_updates: String
  fax: String
  icon: String
  id: String!
  mascot: String
  message_board_read_at: Date
  ml_key: String
  phone: String
  principal: String
  school_timezone: String
  secondary_ad_email: String
  secondary_ad_name: String
  signed_contract_notification: String
  ssn_on_file: String
  state: String
  state_org: String
  state_org_abbreviation: String
  use_security: String
  web_password: String
  zip: String
}
input CreateVehicleInput {
  is_deleted: Boolean
  status: String
  vehicle_type: String
}
input CreateWorkerInput {
  duty: String
  email: String
  event_id: Int
  id: Int!
  organization: String
  paid: String
  pay_code: String
  pay_rate: Float
  salary: Float
  ssn: String
  woker_name: String
  worker_end_time: String
  worker_start_time: String
  worker_type: String
}
input CreateWorkerPool {
  Address: String
  City: String
  First: String!
  Home_Phone: String
  Last: String!
  SSN: String
  State: String
  Work_Phone: String
  Zip: String
  cell_phone: String
  email: String
  pay_rate: Float
  worker_type: String
}
input DeleteEventInput {
  event_id: Int!
}
input DeleteEventParticipantsInput {
  id: Int!
}
input DeleteEventPreparationInput {
  id: Int!
}
input DeleteEventPreparationsInput {
  id: Int!
}
input DeleteEventTransportDetailsInput {
  id: Int!
}
input DeleteFacilityInput {
  place_name: String!
}
input DeleteLevelInput {
  ID: Int!
}
input DeleteManyEventParticipantsInput {
  ids: [Int]!
}
input DeleteManyEventPreparationsInput {
  ids: [Int]!
}
input DeleteManyEventTransportDetailsInput {
  ids: [Int]!
}
input DeleteManyWorkerInput {
  ids: [Int]!
}
input DeleteOfficialDutiesInput {
  ids: [Int!]!
}
input DeleteOfficialInput {
  id: Int!
}
input DeleteOfficialPoolInput {
  ids: [String]!
}
input DeleteOpponentInput {
  SchoolCode: String!
}
input DeletePreparationInput {
  id: Int!
}
input DeleteSchoolInfoInput {
  id: String!
}
input DeleteVehicleInput {
  id: Int!
}
input DeleteWorkerInput {
  id: Int!
}
input DeleteWorkerPoolInput {
  ids: [Int]!
}
input DriveCampaignUpdateInput {
  notes: String
}
input DriveDateCompareInput {
  equals: String
  gt: String
  gte: String
  lt: String
  lte: String
}
input DriveEventActivityInput {
  featured: Boolean
  message: String
  parentId: String
}
input DriveEventAgendaInput {
  description: String
  endTime: String
  location: String
  startTime: String
  title: String
}
input DriveEventAttendeeInput {
  department: String
  flightRequest: EventAttendeeRequestStatus
  hotelRequest: EventAttendeeRequestStatus
  userId: ID
}
input DriveEventBoothInput {
  boothNotes: String
  breakdownEndTime: String
  breakdownStartTime: String
  electricityProvided: Boolean
  flooringProvided: Boolean
  internetProvided: Boolean
  setupEndTime: String
  setupStartTime: String
}
input DriveEventInput {
  activityTypes: [String!]
  agenda: [DriveEventAgendaInput!]
  agendaConfig: JSON
  attendees: [DriveEventAttendeeInput!]
  booth: DriveEventBoothInput
  clinicLeaderId: String
  description: String
  endDate: String
  hotelAddress: String
  hotelName: String
  hubspotTrackingLink: String
  notes: String
  planningCompleted: Boolean
  preferedTimezone: String
  sponsor: DriveEventSponsorInput
  startDate: String
  status: DriveEventStatus
  tier: Int
  title: String
  venue: DriveEventVenueInput
  websiteLink: String
}
input DriveEventSearchInput {
  activityTypes: [String!]
  attendees: [String!]
  boothOptions: DriveEventBoothInput
  dateRange: [String]
  endDate: DriveDateCompareInput
  eventStatus: EventDateStatus
  id: ID
  sponsor: DriveEventSponsorInput
  startDate: DriveDateCompareInput
  states: [String!]
  statuses: [DriveEventStatus!]
  tiers: [Int!]
  title: String
}
input DriveEventSponsorInput {
  doorPrized: Boolean
  doorPrizedRequired: Boolean
  sponsorDescription: String
}
input DriveEventVenueInput {
  buildingOrRoom: String
  city: String
  id: ID
  name: String
  state: String
}
input DriveFieldInput {
  label: String
  linkText: String
  name: String!
  type: DriveFieldType!
  value: String!
}
input DriveFileInput {
  content: String!
  description: String
  name: String!
}
input DriveOrgUserTrackingSearchInput {
  trackingIdStartsWith: String
  trackingType: String
}
input DriveTrackingInput {
  trackingId: String!
  trackingType: String
  trackingValue: String!
  trackingValueType: String
}
input DriveUserSearchInput {
  isInternal: Boolean
  searchTerm: String
  userId: String
}
input DriveVenueSearchInput {
  id: ID
  name: String
  state: String
}
input DynamicEmailDataInput {
  inviterName: String
  organizationName: String
  sponsorshipGroupName: String
  sponsorshipUrl: String
}
input EventCalendarFiltersInput {
  activity: String
  activityName: [String]
  endDate: Date
  facilities: [String]
  gender: String
  group: String
  homeAway: String
  levels: [String]
  opponents: [String]
  startDate: Date
  teams: [String]
  vehicleType: String
}
input EventOfficialReportFilter {
  event_date: Date!
}
input EventParticipantsInput {
  contract_received: String
  event_id: Int
  id: Int!
  notes: String
  paid: String
  school_code: String
}
input EventPreparationsInput {
  comments: String
  event: Int
  id: Int
  prep: String
  qty: String
}
input EventTransportDetailsInput {
  driver_name: String
  driver_phone: String
  event_id: Int
  id: Int!
  vehicle_id: String
  vehicle_type: String
}
input FinancialAddressInput {
  city: String
  line1: String
  line2: String
  state: String
  zip: String
}
input FundraiserSearchParams {
  name: String
}
input GetCompetitionListInput {
  from_date: String
  opponents: [String]
  to_date: String
}
input GetDailyCalendarBusScheduleByDateInput {
  from_date: String
  to_date: String
}
input GetDailyCalendarEventsByDateInput {
  from_date: String
  group: String
  to_date: String
}
input GetDailyCalendarOfficialsByDateInput {
  from_date: String
  to_date: String
}
input GetDailyCalendarPreparationsByDateInput {
  from_date: String
  to_date: String
}
input GetDailyCalendarWorkersByDateInput {
  from_date: String
  to_date: String
}
input GetEventByIdInput {
  event_id: Int!
}
input GetEventParticipantsByIdInput {
  id: Int!
}
input GetEventPreparationsByEventIdInput {
  event_id: Int!
}
input GetEventPreparationsByIdInput {
  id: Int!
}
input GetEventTransportDetailsByEventOrDatesInput {
  event_date_end: Date
  event_date_start: Date
  event_id: Int
}
input GetEventsFilteredByOpponentStartAndEndDate {
  endDate: String!
  opponent: String!
  startDate: String!
}
input GetFacilityByPlaceNameInput {
  place_name: String!
}
input GetLevelByIdInput {
  ID: Int!
}
input GetOfficialAssignmentsInput {
  from_date: String
  gender: String
  levels: [String]
  official_name: String
  teams: [String]
  to_date: String
}
input GetOfficialByIdInput {
  id: Int!
}
input GetOfficialDutyByIdInput {
  id: Int!
}
input GetOfficialPoolByIdInput {
  ID: String
}
input GetOpponentBySchoolCodeInput {
  SchoolCode: String!
}
input GetPreparationByIdInput {
  id: Int!
}
input GetSchoolInfoByIdInput {
  id: String!
}
input GetVehicleByIdInput {
  id: Int!
}
input GetWorkerByIdInput {
  id: Int!
}
input GetWorkerPoolByIdInput {
  ID: Int!
}
input GetWorkersByEventIdInput {
  event_id: Int!
}
input HelpDocumentDeleteInput {
  key: String!
}
input HelpDocumentUploadInput {
  base64File: String!
}
input InsAddPreApprovedContactApproverInput {
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
}
input InsAddPreApprovedContactOrgInput {
  id: String
  modId: String
  name: String
  raiseId: Int
  zipcode: String
}
input InsEditPreApprovedContactInput {
  activity: String
  email: String
  firstName: String
  lastName: String
}
input InsOrgCampaignSummaryInput {
  campaignIds: [Int]
  orgId: String
}
input InsPreApprovedContactInput {
  activity: String!
  email: String!
  firstName: String!
  lastName: String!
}
input InviteCreationInput {
  business: String!
  email: String!
  firstName: String!
  lastName: String
  phone: String
  sponsorshipGroups: CreateInviteSponsorshipGroupRelation!
  status: String
}
input InviteParentArguments {
  joincode: String
}
input InviteUserArguments {
  apps: [UserApps]
  consumer: UserApps
  fundraiserId: Int
  occupation: UserOccupation
  orgs: [InviteUserOrgsArguments]
  permissionIds: [String]
  redirectUrl: String
  roleIds: [String]
}
input InviteUserOrgsArguments {
  orgId: String
  product: UserApps
  roleId: String
}
"Owned by Vault Only used in legacy createCard"
input IssueCardInput {
  altName: String
  cardType: CARD_TYPE!
  metadata: VaultCardMetadataInput
  recipientName: String
  shippingAddress: FinancialAddressInput
  shippingService: SHIPPING_SERVICE
  spendingLimitAmount: Int!
  spendingLimitInterval: SPENDING_LIMIT_INTERVAL!
}
input JoinFundraiserUserInput {
  email: String!
  firstName: String!
  lastName: String!
  phoneNumber: String
}
input ManageAnnouncementFilter {
  orderBy: ManageAnnouncementOrderBy
  skip: Int
  take: Int
  where: ManageAnnouncementWhere
}
input ManageAnnouncementOrderBy {
  endDate: SortOrderEnum
  id: SortOrderEnum
  sortVal: SortOrderEnum
  startDate: SortOrderEnum
  title: SortOrderEnum
}
input ManageAnnouncementWhere {
  id: Int
  onFront: Int
  title: String
}
input ManageCoachListFilter {
  "Defines how the coach list should be ordered."
  orderBy: ManageCoachListOrderBy
  "Number of coaches to skip before starting to fetch the result set."
  skip: Int = 0
  "Limits the number of coaches to fetch from the result set."
  take: Int
  "Conditions to filter the coach list."
  where: ManageCoachListWhere
}
input ManageCoachListOrderBy {
  "Orders coaches based on their address."
  address: SortOrderEnum
  "Orders coaches based on their city."
  city: SortOrderEnum
  "Orders coaches based on their first name."
  firstName: SortOrderEnum
  "Orders coaches based on their last name."
  lastName: SortOrderEnum
  "Orders coaches based on their postal code."
  postalCode: SortOrderEnum
}
input ManageCoachListWhere {
  "Associated Ad ID for the coach."
  adId: Int
  "Unique ID of the coach."
  coachId: Int
  "Timestamp when the coach was created."
  createdAt: Date
  "ID of the user who created the coach entry."
  createdBy: Int
  "First name of the coach."
  firstName: String
  "Indicates if the coach is a head coach."
  headCoach: Boolean
  "Indicates if the coach is approved."
  isApproved: Boolean
  "Last name of the coach."
  lastName: String
  "ID for the coach's photo."
  photoId: Int
  "School's unique ID associated with the coach."
  schoolId: Int
  "ID of the coaching season."
  seasonId: Int
  "Brief description or profile of the coach."
  summary: String
  "Title or position of the coach."
  title: String
  "Timestamp when the coach was last updated."
  updatedAt: Date
  "ID of the user who last updated the coach entry."
  updatedBy: Int
}
"Criteria to filter and sort the list of events."
input ManageEventListFilter {
  "Defines how the list should be ordered."
  orderBy: ManageEventListOrderBy
  "Number of items to skip before starting to fetch the result set."
  skip: Int = 0
  "Limits the number of items to fetch from the result set."
  take: Int = 10
  "Conditions to filter the list."
  where: ManageEventListWhere
}
"Specifies the order in which the event list should be sorted."
input ManageEventListOrderBy {
  "Orders events based on their confirmation status."
  confirmed: String
  "Orders events based on the opponent's name."
  opponent: String
}
"Conditions to filter the event list."
input ManageEventListWhere {
  "Filters events based on their activity or sport type."
  activity: String
  "Filters events based on their author or writer."
  author: String
  "Filters events based on their cancellation status."
  cancellationStatus: String
  "Filters events based on their conference details or name."
  conference: String
  "Filters events based on their related conference event ID."
  conferenceEventId: Int
  "Filters events based on their confirmation status."
  confirmed: String
  "Filters events based on the timestamp when they were created."
  createdAt: Date
  "Filters events based on their location for departure."
  departureLocation: String
  "Filters events based on their direction or map link."
  directionLink: String
  "Filters events based on their estimated time of return."
  estimatedReturnTime: String
  "Filters events based on their date."
  eventDate: Date
  "Filters events based on their title or main heading."
  eventTitle: String
  "Filters events based on whether they exist in the MLS system."
  existsInMls: Int
  "Filters events based on their gender specification."
  gender: String
  "Filters events based on their general status."
  gs: String
  "Filters events based on their level."
  level: String
  "Filters events that take place in a specific month."
  month: Int
  "Filters events based on the opponent's name."
  opponent: String
  "Filters events based on the score achieved by the opponent team."
  opponentScore: String
  "Filters events based on their location or venue."
  place: String
  "Filters events based on their associated team for the season."
  seasonTeam: Int
  "Filters events based on their start time."
  startTime: String
  "Filters events based on the score achieved by the home team."
  teamScore: String
  "Filters events based on their transport comments."
  transportComments: String
  "Filters events based on their transportation details."
  transportation: String
  "Filters events based on the last update timestamp."
  updatedAt: Date
  "Filters events that take place in a specific year."
  year: Int
}
input ManageFacilityFilter {
  orderBy: ManageFacilityOrderBy
  skip: Int
  take: Int
  where: ManageFacilityWhere
  whereNot: ManageFacilityWhere
}
input ManageFacilityOrderBy {
  directions: SortOrderEnum
  indoor: SortOrderEnum
  isDeleted: SortOrderEnum
  locationId: SortOrderEnum
  mlSiteId: SortOrderEnum
  mlSpace: SortOrderEnum
  mlSpaceId: SortOrderEnum
  picture: SortOrderEnum
  placeName: SortOrderEnum
  show: SortOrderEnum
  web: SortOrderEnum
}
input ManageFacilityWhere {
  directions: String
  indoor: String
  isDeleted: Boolean
  locationId: Int
  mlSiteId: Int
  mlSpace: String
  mlSpaceId: Int
  picture: String
  placeName: String
  show: String
  web: String
}
input ManageHeadlineFilter {
  orderBy: ManageHeadlineOrderBy
  skip: Int
  take: Int
  where: ManageHeadlineWhere
}
input ManageHeadlineOrderBy {
  EventResultId: SortOrderEnum
  EventStory: SortOrderEnum
  EventTitle: SortOrderEnum
  RefId: SortOrderEnum
}
input ManageHeadlineWhere {
  EventResultId: Int
  EventStory: String
  EventTitle: String
  RefId: Int
}
input ManageOrganizationFilter {
  "Defines how the organization list should be ordered."
  orderBy: ManageOrganizationOrderBy
  "Number of organizations to skip before starting to fetch the result set."
  skip: Int
  "Limits the number of organizations to fetch from the result set."
  take: Int
  "Conditions to filter the organization list."
  where: ManageOrganizationWhere
}
input ManageOrganizationOrderBy {
  "Orders organizations based on their name."
  name: SortOrderEnum
  "Orders organizations based on their state."
  state: SortOrderEnum
}
input ManageOrganizationWhere {
  "The name of the organization."
  name: String
  "Condition to determine visibility of the organization (e.g., might represent a specific view mode)."
  show: Int
  "The state or province of the organization."
  state: String
}
input ManagePagesFilter {
  orderBy: ManagePagesOrderBy
  skip: Int
  take: Int
  where: ManagePagesWhere
}
input ManagePagesOrderBy {
  name: SortOrderEnum
  pageTitle: SortOrderEnum
}
input ManagePagesWhere {
  name: PagesNameEnum
}
input ManagePhotosFilter {
  orderBy: ManagePhotosOrderBy
  skip: Int = 0
  take: Int
  where: ManagePhotosWhere
  whereNot: ManagePhotosWhere
}
input ManagePhotosOrderBy {
  caption: SortOrderEnum
  filename: SortOrderEnum
  id: SortOrderEnum
  title: SortOrderEnum
}
input ManagePhotosWhere {
  group: String
  image1: Buffer
  needsApproval: Int
  sport: String
}
input ManagePlayerListFilter {
  orderBy: ManagePlayerListOrderBy
  skip: Int = 0
  take: Int
  where: ManagePlayerListWhere
}
input ManagePlayerListOrderBy {
  city: SortOrderEnum
  dob: SortOrderEnum
  fName: SortOrderEnum
  gender: SortOrderEnum
  gradYear: SortOrderEnum
  height: SortOrderEnum
  jersey: SortOrderEnum
  lName: SortOrderEnum
  participantId: SortOrderEnum
  permission: SortOrderEnum
  position: SortOrderEnum
  rosterId: SortOrderEnum
  schoolId: SortOrderEnum
  seasonId: SortOrderEnum
  state: SortOrderEnum
  status: SortOrderEnum
  weight: SortOrderEnum
  zip: SortOrderEnum
}
input ManagePlayerListWhere {
  ch1: Int
  ch2: Int
  ch3: Int
  city: String
  custodyCode: Int
  dayPhone: String
  dob: Date
  fName: String
  feePaid: Int
  gender: String
  gradYear: String
  hatsize: String
  height: String
  homePhone: String
  hospitalPhone: String
  insuranceCompany: String
  insurancePolicyNum: String
  jersey: String
  lName: String
  livesWithCode: Int
  noPress: Int
  participantId: Int
  permission: Int
  physical: Int
  physicalDate: Date
  physician: String
  physicianTelephone: String
  position: String
  preferredHospital: String
  rosterId: Int
  schoolId: Int
  seasonId: Int
  shirtsize: String
  shortsize: String
  stAddress: String
  state: String
  status: String
  studentId: String
  weight: String
  zip: String
}
input ManageProgramListFilter {
  orderBy: ManageProgramListOrderBy
  skip: Int = 0
  take: Int
  where: ManageProgramListWhere
}
input ManageProgramListOrderBy {
  gender: OrderType
  level1: OrderType
  sportName: OrderType
}
input ManageProgramListWhere {
  gender: String
  groupVal: String
  level1: String
  sportName: String
}
input ManageResourceLinkFilter {
  orderBy: ManageResourceLinkOrderBy
  skip: Int
  take: Int
  where: ManageResourceLinkWhere
  whereNot: ManageResourceLinkWhere
}
input ManageResourceLinkOrderBy {
  fileName: SortOrderEnum
  name: SortOrderEnum
}
input ManageResourceLinkWhere {
  fileName: String
  isApproved: Int
  lType: String
  name: String
  onFront: Int
}
input ManageRosterListFilter {
  orderBy: ManageRosterListOrderBy
  skip: Int = 0
  take: Int
  where: ManageRosterListWhere
}
input ManageRosterListOrderBy {
  city: SortOrderEnum
  dob: SortOrderEnum
  fName: SortOrderEnum
  gender: SortOrderEnum
  gradYear: SortOrderEnum
  height: SortOrderEnum
  jersey: SortOrderEnum
  lName: SortOrderEnum
  participantId: SortOrderEnum
  permission: SortOrderEnum
  position: SortOrderEnum
  rosterId: SortOrderEnum
  schoolId: SortOrderEnum
  seasonId: SortOrderEnum
  state: SortOrderEnum
  status: SortOrderEnum
  weight: SortOrderEnum
  zip: SortOrderEnum
}
input ManageRosterListWhere {
  ch1: Int
  ch2: Int
  ch3: Int
  city: String
  custodyCode: Int
  dayPhone: String
  dob: Date
  fName: String
  feePaid: Int
  gender: String
  gradYear: String
  hatsize: String
  height: String
  homePhone: String
  hospitalPhone: String
  insuranceCompany: String
  insurancePolicyNum: String
  jersey: String
  lName: String
  livesWithCode: Int
  noPress: Int
  participantId: Int
  permission: Int
  physical: Int
  physicalDate: Date
  physician: String
  physicianTelephone: String
  position: String
  preferredHospital: String
  rosterId: Int
  schoolId: Int
  seasonId: Int
  shirtsize: String
  shortsize: String
  stAddress: String
  state: String
  status: String
  studentId: String
  weight: String
  zip: String
}
input ManageSeasonListFilter {
  orderBy: ManageSeasonListOrderBy
  skip: Int = 0
  take: Int
  where: ManageSeasonListWhere
}
input ManageSeasonListOrderBy {
  sport_code: OrderType
  year: OrderType
}
input ManageSeasonListWhere {
  sport_code: String
  year: String
}
input ManageSportDetailsListFilter {
  orderBy: ManageSportDetailsListOrderBy
  skip: Int = 0
  take: Int
  where: ManageSportDetailsListWhere
}
input ManageSportDetailsListOrderBy {
  createdAt: OrderType
  createdBy: OrderType
  defaultToSchedulePage: OrderType
  gender: OrderType
  groupVal: OrderType
  homeField: OrderType
  introHtml: OrderType
  introImageID: OrderType
  level1: OrderType
  needsApproval: OrderType
  recordStatus: OrderType
  schoolId: OrderType
  siteSchoolSport: OrderType
  sportCode: OrderType
  sportDescription: OrderType
  sportName: OrderType
  sportStatus: OrderType
  updatedAt: OrderType
  updatedBy: OrderType
}
input ManageSportDetailsListWhere {
  createdAt: Date
  createdBy: Int
  defaultToSchedulePage: Int
  introHtml: String
  introImageID: Int
  needsApproval: Int
  recordStatus: Int
  siteSchoolSport: Int
  updatedAt: Date
  updatedBy: Int
}
input ManageTeamStatsFilter {
  orderBy: ManageTeamStatsOrderBy
  skip: Int
  take: Int
  where: ManageTeamStatsWhere
}
input ManageTeamStatsOrderBy {
  pageHtml: PagesNameEnum
  sport: PagesNameEnum
}
input ManageTeamStatsWhere {
  pageHtml: String
  sport: String
}
input ManageUserCreateInput {
  contracts: String!
  events: String!
  groups: [String!]
  maintenance: String!
  password: String!
  seasons: String!
  teams: String!
  user_email: String!
  user_id: String!
  user_level: String!
}
input ManageUserDeleteInput {
  id: Int!
}
input ManageUserInput {
  id: Int!
}
input ManageUserUpdateInput {
  contracts: String
  events: String
  groups: [String!]
  id: Int!
  maintenance: String
  password: String
  seasons: String
  teams: String
  user_email: String
  user_id: String
  user_level: String
}
input ManageUsersListOptions {
  keyword: String
  limit: Int
  offset: Int
}
input ModifyEventInput {
  activity: String
  author: String
  bus_fee: Float
  bus_time: String
  cancellation_status: String
  comments: String
  conference: String
  conference_event_id: Int
  conference_id: Int
  confirmed: String
  contract: String
  created_at: Date
  departure_location: String
  directions: String
  early_dismissal_required: String
  early_dismissal_time: String
  end_time: String
  estimated_return_time: String
  event_date: Date
  event_id: Int!
  exists_in_mls: Int
  fee: Float
  g_s: String
  gate_revenue: Float
  headline: String
  impact_event: String
  lead: String
  location: String
  loss_points: Int
  num_buses: Int
  opponent: String
  opponent_code: String
  opponent_score: String
  picture: String
  place: String
  prep_setup: String
  promote: String
  results: String
  revenue: Float
  rollover: String
  season_team: Int
  start_time: String
  team_score: String
  title: String
  tournament: String
  trans_id: Int
  transport_comments: String
  transportation: String
  update_at: Date
  web_dir: String
  win_points: Int
  years: String
}
input ModifyEventParticipantsInput {
  contract_received: String
  event_id: Int
  id: Int!
  notes: String
  paid: String
  school_code: String
}
input ModifyEventPreparationInput {
  comments: String
  event: Int
  id: Int!
  prep: String
  qty: String
}
input ModifyEventPreparationsInput {
  comments: String
  event: Int
  id: Int!
  prep: String
  qty: String
}
input ModifyEventTransportDetailsInput {
  driver_name: String
  driver_phone: String
  event_id: Int
  id: Int!
  vehicle_id: String
  vehicle_type: String
}
input ModifyFacilityInput {
  Address1: String
  Address2: String
  City: String
  State: String
  ZipCode: String
  directions: String
  indoor: String
  ml_site_id: String
  ml_space: String
  ml_space_id: String
  picture: String
  place_name: String!
  place_name_old: String!
  show: String
  web: String
}
input ModifyLevelInput {
  ID: Int!
  Level: String
  is_deleted: Boolean
}
input ModifyManyEventPreparationsByEventInput {
  comments: String
  event: Int!
  prep: String
  qty: String
}
input ModifyOfficialDutyInput {
  duty: String
  id: Int!
  is_deleted: Boolean
}
input ModifyOfficialInput {
  duty: String
  event_id: Int
  id: Int!
  offic_id: String
  organization: String
  paid: String
  pay_code: String
  received: String
  salary: Float
  ssn: String
  voucher_number: String
  worker_name: String
}
input ModifyOfficialPoolByIdInput {
  Address: String
  City: String
  First: String
  Home_Phone: String
  ID: String!
  ID_old: String!
  Last: String
  SSN: String
  State: String
  Work_Phone: String
  Zip: String
  cell_phone: String
  email: String
  is_deleted: Boolean
  vendor_number: String
}
input ModifyOpponentInput {
  Address: String
  Phone: String
  SchoolCode: String!
  SchoolName: String
  State: String
  Zip: String
  ad_name: String
  city: String
  email: String
  fax: String
  is_deleted: Boolean
  nces_id: String
  non_school: Boolean
}
input ModifyPreparationInput {
  duty: String
  id: Int!
  is_deleted: Boolean
  qty: String
}
input ModifySchoolInfoInput {
  Schoolname: String
  ad: String
  ad_contract_signee: String
  address: String
  ccemail: String
  city: String
  conf_text_type: String
  email: String
  email_reminder: String
  email_reminder_officials: String
  email_reminder_workers: String
  enable_cc_email_as_origin: String
  enable_ml_updates: String
  fax: String
  icon: String
  id: String!
  mascot: String
  message_board_read_at: Date
  ml_key: String
  phone: String
  principal: String
  school_timezone: String
  secondary_ad_email: String
  secondary_ad_name: String
  signed_contract_notification: String
  ssn_on_file: String
  state: String
  state_org: String
  state_org_abbreviation: String
  use_security: String
  web_password: String
  zip: String
}
input ModifyVehicleInput {
  id: Int!
  is_deleted: Boolean
  status: String
  vehicle_type: String
}
input ModifyWorkerInput {
  duty: String
  email: String
  event_id: Int
  id: Int!
  organization: String
  paid: String
  pay_code: String
  pay_rate: Float
  salary: Float
  ssn: String
  woker_name: String
  worker_end_time: String
  worker_start_time: String
  worker_type: String
}
input ModifyWorkerPoolInput {
  Address: String
  City: String
  First: String
  Home_Phone: String
  ID: Int!
  Last: String
  SSN: String
  State: String
  Work_Phone: String
  Zip: String
  cell_phone: String
  email: String
  is_deleted: Boolean
  pay_rate: Float
  worker_type: String
}
input NoticeCreateInput {
  body: String
  isUrgent: Int
  title: String
}
input NoticeDeleteInput {
  ids: [Int]
}
input NoticeModifyInput {
  body: String
  id: Int!
  isUrgent: Int
  title: String
}
input OfficialByIdInput {
  id: Int!
}
input OrderFilterInput {
  limit: Int
  offset: Int
  orderBy: String
  orderBySort: String
  scopeId: Int!
  searchBy: String
  searchValue: String
  status: String
}
input OrderGraphInput {
  interval: Int
  scopeId: Int!
}
input OrganizationSearchParams {
  id: Int
  name: String
}
input OrgsSearchPaginationInput {
  limit: Int = 25
  offset: Int = 0
}
input OrgsSearchWhereInput {
  "List of organization ids to filter from."
  ids: [ID!]
  "The string to search in name of organization."
  nameIncludes: String
  """
  Organization type. Valid values are "Booster" | "Club" | "District" | "Program" | "School".
  """
  orgTypes: [OrgType!]
  "Allow to search any properties via JSON query. The key will auto convert to snake_case."
  properties: JSON
}
input PaymentsApiCustomerInput {
  email: String!
  stripeEnv: StripeEnv = RAISE
}
input PaymentsApiDetachPaymentMethodInput {
  paymentMethodId: String!
  stripeEnv: StripeEnv = RAISE
}
input PaymentsApiPaymentIput {
  amount: Int!
  description: String
  finalDestination: String!
  idempotencyKey: String
  metadata: JSONObject
  paymentMethodId: String!
  snapAmount: Int = 0
  snapId: String!
  stripeEnv: StripeEnv = RAISE
}
input PaymentsApiRefundInput {
  amount: Int
  metadata: JSONObject
  refundApplicationFee: Boolean = false
  stripeEnv: StripeEnv = RAISE
  transactionId: String!
}
input PointsActivityFilterInput {
  limit: Int
  offset: Int
  orderBy: String
  orderBySort: String
  scopeId: Int!
  searchBy: String
  searchValue: ID
  status: String
}
input PrefundSearchParams {
  id: String
  name: String
  status: [PREFUND_STATUS]
}
input PreparationByIdInput {
  id: Int!
}
input ReconcileBudget {
  amount: Int!
  budgetItemId: String!
}
input ReconcileInvoice {
  amount: Int!
  invoiceId: String!
}
input RoleArguments {
  description: String
  name: String!
  scope: String
  title: String!
}
input SeasonByIdInput {
  season_id: Int!
}
input SeasonByYearTeamInput {
  sport_code: String
  year: String
}
input SeasonCreateInput {
  budget: Float
  created_at: Date
  default_time_for_event: String
  default_time_for_practice: String
  home_field: String
  is_deleted: Boolean
  preview: String
  season: String
  season_id: Int!
  sport_code: String
  web_password: String
  year: String
}
input SeasonDeleteInput {
  season_ids: [Int]
}
input SeasonEventWizardInput {
  season_ids: [Int]
}
input SeasonModifyInput {
  budget: Float
  created_at: Date
  default_time_for_event: String
  default_time_for_practice: String
  home_field: String
  is_deleted: Boolean
  preview: String
  season: String
  season_id: Int!
  sport_code: String
  web_password: String
  year: String
}
input SeasonPostponeUnpostponeInput {
  event_ids: [Int]
  season_id: Int
}
input SeasonScheduleTeamsCreateInput {
  sport_codes: [String]
  year: String
}
input ShipmentInput {
  campaignId: Int
  externalId: String
}
input SpendAccountBearerToken {
  verificationCode: String
  verificationToken: String
}
input SpendAccountTransferInput {
  amount: Int!
  description: String!
  fromGroupIdOrOrgId: String!
  toGroupIdOrOrgId: String!
}
input SpendAchPaymentCancelInput {
  externalId: String!
  id: String!
}
input SpendAchPaymentInput {
  description: String
  externalId: String!
  groupId: String!
  invoiceIds: [String]!
  paymentAmount: Int!
}
input SpendAddressInput {
  city: String
  state: String
  street: String
  zip: String
}
input SpendBudgetInput {
  categoryId: String!
  description: String!
  isDefault: Boolean
  seasonId: String
  targetAmount: Int!
  targetDateAt: String!
  vaultId: String
}
input SpendCategoryInput {
  isDefault: Boolean
  isHidden: Boolean
  name: String
  type: CategoryTypeEnum
}
input SpendDebitCardInput {
  dateOfBirth: String!
  shipping: SpendDebitCardShippingInput
  userId: String!
}
input SpendDebitCardShippingInput {
  city: String!
  postalCode: String!
  state: String!
  street: String!
}
input SpendGroupCheckDepositTagsInput {
  checkDepositId: String!
  groupId: String
}
input SpendGroupExternalTransferInput {
  accountId: String
  amount: Int
  direction: ExternalTransferDirectionEnum
  id: String
  note: String
}
input SpendGroupInput {
  hasAccount: Boolean
  isBudgetShared: Boolean
  isLinkEnabled: Boolean!
  isRequireAgreement: Boolean
  name: String!
  seasonEndAt: String!
  seasonName: String
  seasonStartAt: String!
}
input SpendGroupRosterInput {
  email: String!
  groupId: String!
  name: String!
  seasonId: String!
}
input SpendGroupRostersInput {
  groupId: String!
  rosters: [SpendRosterUserInput]
  seasonId: String!
}
input SpendGroupRostersWhereInput {
  groupNameIncludes: String
  ids: [String!]
  nameIncludes: String
  status: SpendGroupRosterStatusEnum
}
input SpendGroupsWhereInput {
  "Search archived groups only"
  archived: Boolean
  "Search by group name only"
  groupNameIncludes: String
  "Search by list of group id"
  ids: [String!]
  "Search by group name or latest season name in group"
  nameIncludes: String
  "Search by payment schedule status of latest season in group. Support multiple values. (OR operation)"
  paymentScheduleStatus: [String!]
}
input SpendGuardianSignupInput {
  groupId: String!
  rosterName: String!
  seasonId: String!
}
input SpendInviteInput {
  email: String!
  firstName: String!
  groupId: String
  lastName: String!
  type: SpendInviteType!
  userId: String
}
input SpendInviteWhereInput {
  "Search invitation which is archived"
  archived: Boolean
  "Search by group id"
  groupId: String
  "Search by invite name"
  nameIncludes: String
  "Search by roster name only"
  rosterNameIncludes: String
  "Search by invite status: accepted, pending, undeliverable"
  status: String
  "Search by invite types. Valid values: guardian,group_staff,program_staff, program_observer,program_admin"
  type: [SpendInviteType!]
  "Search by invite type context: group or program. This will be affect invite type filter."
  typeContext: String
}
input SpendInvoiceFilter {
  by: InvoiceReportFilterEnum!
  value: String!
}
input SpendInvoiceInput {
  amount: Int
  balanceDue: Int
  budgetItemId: String
  description: String
  dueDate: String
  groupRosterId: String
  isOptional: Boolean
  note: String
  optedIn: Boolean
  paid: Boolean
  paidDate: String
  paymentScheduleInvoiceId: String
}
input SpendInvoicePaymentDeauthorizeInput {
  invoiceId: String
  message: String
}
input SpendInvoicePaymentMethodUpdate {
  ids: [String!]!
  paymentMethodId: String!
  paymentMethodSource: String!
}
input SpendInvoiceRefundInput {
  amount: Int!
  invoiceId: String!
}
input SpendInvoiceReminderInput {
  email: String
  failedPayment: Boolean
  groupName: String
  invoiceId: String
  pastDue: Boolean
}
input SpendInvoiceRequestChangeInput {
  invoiceId: String!
  note: String!
}
input SpendNotificationInput {
  email: [String!]!
  groupId: String
  isEmailCCed: Boolean!
  message: String!
  subject: String
}
input SpendOrganizationCheckDepositTagsInput {
  checkDepositId: String!
}
input SpendOrganizationExternalTransferInput {
  accountId: String
  amount: Int
  direction: ExternalTransferDirectionEnum
  note: String
}
input SpendOrganizationInput {
  address: SpendAddressInput!
  email: String!
  legalName: String!
  logo: String!
  phone: String!
  website: String!
}
input SpendOrganizationsWhereInput {
  ids: [String!]
  nameIncludes: String
  "orgId is equivalent to externalId or id from orgs-api"
  orgIds: [String!]
  states: [String!]
  status: OrganizationFilterEnum
}
input SpendPaginationInput {
  limit: Int
  offset: Int
}
input SpendPaymentMethodDetach {
  paymentMethodId: String!
}
input SpendPaymentMethodInput {
  amount: Int
  hasApprovedAgreement: Boolean
  invoiceIds: [String]
  isAutoPayAuthorized: Boolean
  paymentMethodId: String
  paymentMethodSource: String
  paymentMethodTiming: String
}
input SpendPaymentScheduleBySeasonInput {
  seasonId: String
  status: String
}
input SpendPaymentScheduleInput {
  amountDue: Int
  budgetItemId: String
  description: String
  dueDate: String
  groupId: String
  isOptional: Boolean
  note: String
  seasonId: String
  status: String
}
input SpendRosterUserInput {
  email: String!
  name: String!
}
input SpendSeasonInput {
  endDateAt: String
  groupId: String
  isBudgetShared: Boolean
  isLinkEnabled: Boolean
  name: String
  startDateAt: String
}
input SpendSettingsInput {
  enableGroupBanks: Boolean
  enableProgramAgreements: Boolean
  notifyBankActivityAdmins: Boolean
  notifyDueFrequencies: [String!]
  notifyFailedAchAdmins: Boolean
  notifyPastDueAdmins: Boolean
  notifyPastDueNonUsers: Boolean
  notifyUpcomingNonUsers: Boolean
  "@deprecated: pastDueFrequency is replaced with notifyDueFrequencies"
  pastDueFrequency: Int
}
input SpendSignupAgreementInput {
  content: String!
  name: String!
}
input SpendSortInput {
  field: String!
  order: SpendSortOrderEnum
}
input SpendTransactionAttachmentInput {
  "Base-64 encoded file"
  content: String!
  description: String
  "Filename with extension"
  name: String!
  paymentId: String!
}
input SpendTransactionFilter {
  by: TransactionReportFilterEnum!
  value: String!
}
input SpendTransactionInput {
  direction: String
  externalId: String
  externalPaymentId: String
  invoiceIdList: [String]
  source: String
}
input SpendTransactionReconcileInput {
  budgets: [ReconcileBudget]
  invoices: [ReconcileInvoice]
  ledgerTransactionAmount: Int!
  ledgerTransactionId: String!
}
input SpendTranscationNoteInput {
  content: String!
  paymentId: String!
}
input SpendUpsertCategoryInput {
  id: String
  isDefault: Boolean!
  isHidden: Boolean!
  name: String!
  type: CategoryTypeEnum!
}
input SpendUserSignupInput {
  groupId: String!
  status: String!
}
input SponsorshipGroupConnect {
  sponsorshipGroup: Connect
}
input StoreBuildRequester {
  email: String
  name: String!
}
input StoreByCampaignIdsInput {
  all: Boolean
  campaignIds: [Int!]!
  limit: Int
  offset: Int
  orderBy: String
  orderBySort: String
  scopeIds: [Int]
}
input StoreByGLEmailInput {
  all: Boolean
  email: String!
  limit: Int
  offset: Int
  orderBy: String
  orderBySort: String
  scopeIds: [Int]
}
input StoreCreatePaymentIntent {
  amount: Float!
  email: String!
  paymentMethod: String
  userSsoId: String!
}
input StoreCustomerInput {
  email: String!
  firstName: String!
  lastName: String!
  phoneNumber: String
}
input StoreEditInfoInput {
  activityType: String
  brands: [Int]
  productColors: [Int]
  scopeId: Int!
  storeCode: String!
  storeName: String
}
input StoreGLInput {
  email: String!
  firstName: String!
  lastName: String!
  phoneNumber: String
}
input StoreManagerUpdatePoints {
  managerEmail: String!
  managerId: Int!
  points: Float!
  scopeId: Int!
}
input StoreParticipantInput {
  email: String!
  firstName: String!
  lastName: String!
  phoneNumber: String
}
input StorePointEarnedGraphInput {
  interval: Int
  managerId: Int!
  scopeId: Int!
}
input StoreSaveTransaction {
  amount: Float!
  email: String!
  points: Float!
  scopeId: Int!
  transactionInfo: String!
  userSsoId: String!
}
input StoreSender {
  email: String!
  scopeId: Int!
  senderId: Int!
}
input StoreStatusInput {
  reasonWhy: StoreStatusReasonWhy
  scopeId: Int!
  status: Boolean!
}
input StoreStatusReasonWhy {
  comment: String
  commentOption: String
}
input StoreSummaryByCampaignIdsInput {
  campaignIds: [Int!]!
  scopeIds: [Int]
  timeline: Int
}
input StoreTicketInput {
  message: String!
  requester: StoreTicketRequester!
  scopeId: Int!
  storeCode: String!
  subject: String!
}
input StoreTicketRequester {
  email: String!
  name: String!
}
input StoreTransferCustomer {
  customer: StoreCustomerInput
  points: Float!
  sender: StoreSender
}
input StoreTransferGL {
  groupLeader: StoreGLInput
  points: Float!
  sender: StoreSender
}
input StoreTransferParticipant {
  participant: StoreParticipantInput
  points: Float!
  sender: StoreSender
}
input StoreUserCampaignsInput {
  all: Boolean
  demo: Boolean
  limit: Int
  offset: Int
  orderBy: String
  orderBySort: String
  searchBy: String
  searchValue: ID
}
input StoreUserParticipantsInput {
  all: Boolean
  campaignIds: [Int!]!
  limit: Int
  offset: Int
}
input StoresSummaryByGLEmailInput {
  email: String!
  scopeIds: [Int]
  timeline: Int
}
input TeamByCodeInput {
  sport_code: String!
}
input TeamCreateInput {
  facility: String
  gender: String
  groupval: String
  home_field: String
  is_deleted: Boolean
  level1: String
  sport_code: String
  sport_description: String
  sport_name: String
}
input TeamDeleteInput {
  sport_code: String!
}
input TeamModifyInput {
  facility: String
  gender: String
  groupval: String
  home_field: String
  is_deleted: Boolean
  level1: String
  sport_code: String
  sport_description: String
  sport_name: String
}
input TeamOfficialCreateInput {
  id: Int!
  pay: Float
  pay_code: String
  sport: String!
  worker_duty: String
}
input TeamOfficialDeleteInput {
  id: Int!
}
input TeamOfficialModifyInput {
  id: Int!
  pay: Float
  pay_code: String
  worker_duty: String
}
input TeamPreparationCreateInput {
  id: Int!
  prep: Int!
  qty: String
  sport: String!
}
input TeamPreparationDeleteInput {
  id: Int!
}
input TeamPreparationModifyInput {
  id: Int!
  prep: Int
  qty: String
}
input TeamWorkerCreateInput {
  home_field: String
  id: Int!
  pay: Float
  pay_code: String
  sport: String!
  worker_duty: String
  worker_name: String
}
input TeamWorkerDeleteInput {
  id: Int!
}
input TeamWorkerModifyInput {
  home_field: String
  id: Int!
  pay: Float
  pay_code: String
  worker_duty: String
  worker_name: String
}
input TransactionsInput {
  createdAfter: Timestamp
  createdBefore: Timestamp
  destination: String
  externalId: String
  metadata: JSONObject
  source: String
  status: Status
}
input UnconfirmedEventsFiltersInput {
  activity: String
  gender: String
  levels: [String]
  limit: Int
  offset: Int
  opponents: [String]
  teams: [String]
  year: String
}
input UpsertEventParticipantsInput {
  eventParticipantsArray: [EventParticipantsInput]!
}
input UpsertEventPreparationsInput {
  eventPreparationsArray: [EventPreparationsInput]!
}
input UpsertEventTransportDetailsInput {
  eventTransportDetailsArray: [EventTransportDetailsInput]!
}
input UpsertFacilitiesInput {
  address1: String
  address2: String
  city: String
  directions: String
  facility_name: String!
  location_id: Int
  state: String
  zipCode: String
}
input UpsertManyWorkersInput {
  workersArray: [CreateWorkerInput]!
}
input UpsertOfficialDutiesInput {
  duty: String
  id: Int
}
input UpsertOfficialsInput {
  address: String
  cell_phone: String
  email: String
  first_name: String
  home_phone: String
  last_name: String
  official_id: String!
  ssn: String
  work_phone: String
  zip: String
}
input UpsertOpponentsInput {
  ad_name: String
  address: String
  city: String
  email: String
  fax: String
  phone: String
  school_code: String!
  school_name: String
  state: String
  zip: String
}
input UpsertWorkersInput {
  cell_phone: String
  email: String
  first_name: String
  home_phone: String
  id: Int
  last_name: String
  pay_rate: Float
  ssn: String
  worker_type: WorkerTypes
}
input UrgentAnnouncementFilter {
  orderBy: ManageAnnouncementOrderBy
  skip: Int
  take: Int
}
input UserPermissionAssignment {
  id: String!
  scope: String
}
"Used for addresses in VaultKyb, VaultKyc and latestCreateCard"
input VaultAddressInput {
  city: String!
  postalCode: String!
  region: String!
  street: String!
  unit: String
}
"used in vaultKybUpdate and vaultKycUpdate"
input VaultAddressUpdateInput {
  city: String
  postalCode: String
  region: String
  street: String
  unit: String
}
"Additional data passed into the Stripe api Can be read in Stripe dashboard"
input VaultCardMetadataInput {
  description: String
  walletId: String
}
"Day, Month and Year of birth"
input VaultDobInput {
  day: String!
  month: String!
  year: String!
}
"ip and date of Stripe ToS acceptance"
input VaultTosAcceptance {
  date: DateTime!
  ip: String!
}
"Input object for index query filters."
input Where {
  ""
  and: [String]
  ""
  between: [String]
  ""
  eq: [String]
  ""
  gt: [String]
  ""
  gte: [String]
  ""
  lt: [String]
  ""
  lte: [String]
  ""
  partition: [String]
  ""
  startsWith: [String]
}
input WorkerByIdInput {
  id: Int!
}
input assetCreationInput {
  assetTypeId: String!
  createdAt: String
  description: String
  expirationDate: String!
  image: String
  location: String
  name: String!
  pricing: Float
  quantity: Int!
  sponsorshipGroupId: String!
  startDate: String!
}
input eventContractItemInput {
  event_id: Int!
}
input iSocialMediaAccounts {
  facebook: String
  instagram: String
  twitch: String
  twitter: String
}
input iSponsorDistrictFields {
  name: String!
}
input iSponsorSchoolFields {
  name: String!
  streetAddress: String!
  zipCode: String!
}
input iSponsorSchoolProgramFields {
  description: String!
  name: String!
}
input orderByClauseGroups {
  name: String
  pricing: String
}
input orderByClauseInvites {
  business: String
  email: String
  firstName: String
  phone: String
  updatedAt: String
}
input orderByPackages {
  orderedAt: String
}
input searchByName {
  contains: String
  mode: String
}
input sponsorshipGroupUserLink {
  sponsorshipGroupId: String!
  userId: String!
  userType: String
}
input storeBuildRequestInput {
  campaignId: Int
  comment: String
  primaryColor: String!
  requester: StoreBuildRequester!
  secondaryColor: String!
  storeActivity: String!
  storeLogo: String!
  storeName: String!
}
input whereClauseAssetTypes {
  isActive: Boolean
}
input whereClauseAssets {
  activityIds: [String]
  archived: Boolean
  assetTypeIds: [String]
  maxPrice: Int
  minPrice: Int
  name: searchByName
  radius: Int = 1
  sponsorshipGroupIds: [String]
  stateId: String
  status: String
  zipCode: String
}
input whereClauseInvites {
  email: searchByName
  sponsorshipGroupId: String!
  status: Boolean
}
input whereClausePackages {
  status: String
}
input whereClauseSponsorShipGroups {
  activityIds: [String]
  name: searchByName
  schoolId: String
  status: Boolean
}
input whereClauseSponsors {
  name: searchByName
  status: Boolean
}
input whereClauseSponsorshipGroupOrders {
  name: searchByName
  sponsorshipGroupId: String
  status: OrderStatus
}
"Exposes a URL that specifies the behavior of this scalar."
directive @specifiedBy(
    "The URL that specifies the behavior of this scalar."
    url: String!
  ) on SCALAR
